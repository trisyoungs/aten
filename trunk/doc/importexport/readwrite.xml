<chapter id="readwrite"><title>Reading and Writing</title>

	** ((Delimited Reading and Writing)) - How delimited reading and writing works
	** ((Unformatted Reading and Writing)) - Working with binary data

<para>Formatted output in Aten is based largely on string formatting in C, so if you're familiar with C then this should be a breeze. If you're a Soldier of Fortran, then the principles are very similar. If you're familiar with neither, then now's the time to learn.</para>

^See also:
*((Delimited Reading and Writing)) for information on reading and writing data without formatting strings
*((Unformatted Reading and Writing)) for information on reading data from binary files^

<section id="readwrite.formatted"><title>Formatted Output</title>

<para>Formatted output corresponds to output to either the screen or to files, and is used in the following commands:</para>

<table frame='all'><title>XXXXX</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>
<colspec colname='command'/>
<colspec colname='function'/>
<thead>
<row>
  <entry>Command</entry>
  <entry>Function</entry>
</row>
</thead>
<tbody>
<row>
  <entry>error</entry>
  <entry>Write a message to the screen and immediately terminate execution of the current script / filter / command structure</entry>
</row>
<row>
  <entry>printf</entry>
  <entry>Write a message to the screen</entry>
</row>
<row>
  <entry>verbose</entry>
  <entry>Write a message to the screen, provided verbose output mode is on</entry>
</row>
<row>
  <entry>writelinef</entry>
  <entry>Write a formatted line to the current output file</entry>
</row>
<row>
  <entry>writevarf</entry>
  <entry>Write a formatted string to a variable (equivalent to the C 'sprintf' command)</entry>
</row>
</tbody>
</tgroup>
</table>

<para>Note that all are called the same as their ((Delimited Reading and Writing|delimited counterparts)), but with the addition of an 'f' at the end of the name.</para>

<section id="readwrite.formatted.basic"><title>Basic Strings</title>

<para>Formatting a string for output, as mentioned elsewhere on numerous occasions, works the same as for C. The C 'printf' command (equivalent to the command of the same name in Aten) takes a character string as its first argument, and at its simplest, this is all that is required:</para>

<synopsis>
printf(&quot;Hello&quot;);
</synopsis>

<para>This prints 'Hello' to the screen (minus the quotes). Importantly, however, a newline character is __not__ printed, meaning that the next thing you try and 'printf' will appear on the same line. For instance:</para>

<synopsis>
printf(&quot;Hello&quot;);
printf(&quot;There.&quot;);
</synopsis>

<para>would output:</para>

<synopsis>
HelloThere.
</synopsis>

<para>The end of a character constant in the printf command does not implicitly mean 'and this is the end of the line' - you must indicate the end of the line yourself by placing '\n' at the point where you wish the line to end. So:</para>

<synopsis>
printf(&quot;Hello\n&quot;);
printf(&quot;There.&quot;);
</synopsis>

<para>would output:</para>

<synopsis>
Hello
There.
</synopsis>

<para>Newlines (\n) are an example of <link linkend="readwrite.escaped">escaped characters</link> - the backslash '\' indicates that the following character, in this case 'n', is not to be treated as a normal 'n', but instead will take on its alternative 'meaning', in this case a newline. There are one or two other escaped characters recognised - see <link linkend="readwrite.escaped">Escaped Characters</link> for a list. Note that the newline token can appear anywhere in the string, and any number of times. So:</para>

<synopsis>
printf(&quot;Hello\nThere\n.&quot;);
</synopsis>

</para>would output:</para>

<synopsis>
Hello
There
.
</synopsis>

</section>

<section id="readwrite.printingdata"><title>Printing Data</title>

<para>Being able to print simple text strings is good, but not nearly enough. The first argument to the 'printf' command must always be a character string, but any number of additional arguments may be provided. Now, these additional arguments may be number constants, other character strings, variables, etc., and may be output in the resulting string by referencing them with 'specifiers' placed within the first example. One example of a specifier is '%i' which is shorthand for saying 'an integer value' - if used within the character string provided to printf, the command will expect an integer constant or variable to be provided as an additional argument. For example:</para>

<synopsis>
printf(&quot;This number is %i.\n&quot;, 10);
</synopsis>

<para>will print</para>

<synopsis>
This number is 10.
</synopsis>

<para>Similarly,</para>

<synopsis>
int value = 1234;
printf(&quot;Constant is %i, variable is %i.\n&quot;, 10, value);
</synopsis>

<para>will print</para>

<synopsis>
Constant is 10, variable is 1234.
</synopsis>

<para>There are other <link linkend="readwrite.specifiers">specifiers</link> suitable for different types of data. The way data is presented by the specifier in the final output can also be controlled (e.g. for numerical arguments the number of decimal places, presence of exponentiation, etc., can be defined).</para>

</section>

<section id="readwrite.formattedinput"><title>Formatted Input</title>

<para>Formatted input corresponds to input from either files or string variables, and is used in the following commands:</para>

<table frame='all'><title>XXXXX</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<colspec colname='command'/>
<colspec colname='function'/>
<thead>
<row>
  <entry>Command</entry>
  <entry>Function</entry>
</row>
</thead>
<tbody>
<row>
  <entry>readlinef</entry>
  <entry>Read a formatted line from the current input file</entry>
</row>
<row>
  <entry>readvarf</entry>
  <entry>Read a formatted string from a variable</entry>
</row>
</tbody>
</tgroup>
</table>

<para>Note that the meaning of the formatting string changes slightly here - in essence, the type and formats of the specifiers are used to break up the supplied string into separate arguments, which are then placed in the provided corresponding variable arguments. When reading in string data, note that blank characters are significant and will be retained. To strip trailing blank characters (spaces and tabs) when reading a fixed-length string in a format, supply the length as a negative number.</para>

</section>

<section id="readwrite.specifiers"><title>Specifiers</title>

<para>The list of allowable variable specified corresponds more or less exactly to that found in C, with some small omissions and minor inclusions. For a full list see [http://www.cplusplus.com/reference/clibrary/cstdio/printf/] or [http://www.cppreference.com/wiki/c/io/printf]. Make sure you look at the following section to see the (short) list of subtle differences between the C standard and Aten.</para>

<para><emphasis>Note: To print out reference addresses, use '%li'.</emphasis></para>

<section id="readwrite.specifiers.differences"><title>Differences Between C and Aten</title>

* The pointer specifier '%p' is not supported.
* The single-character specifier '%c' is not supported.
* Output of long doubles by prefixing a specifier with 'L' (e.g. '%Le') is not supported.

</section>

<section id="readwrite.specifiers.extra"><title>Extra Specifiers Within Aten</title>

<para>As well as the mostly complete standard set of specifiers provided by C, Aten also includes some other useful specifiers that may be used in formatted input and output.</para>

<table frame='all'><title>XXXXX</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<colspec colname='specifier'/>
<colspec colname='meaning'/>
<thead>
<row>
  <entry>Specifier</entry>
  <entry>Meaning</entry>
</row>
</thead>
<tbody>
<row>
  <entry>%*</entry>
  <entry>Relevant to formatted input only. Discard the next item, regardless of its type. A corresponding variable argument need not be provided</entry>
</row>
<row>
  <entry>%r</entry>
  <entry>Read characters (starting from the next delimited argument) until the end of the input line is encountered (i.e. 'rest-of-line' specifier). A corresponding string variable should be provided</entry>
</row>
</tbody>
</tgroup>
</table>

</section>

</section>

<section id="readwrite.escaped"><title>Escaped Characters</title>

<table frame='all'><title>XXXXX</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
<colspec colname='escape sequence'/>
<colspec colname='meaning'/>
<thead>
<row>
  <entry>Escape Sequence</entry>
  <entry>Meaning</entry>
</row>
</thead>
<tbody>
<row>
  <entry>\n</entry>
  <entry>Print newline (next character will appear on the next line)</entry>
</row>
<row>
  <entry>\r</entry>
  <entry>Carriage return</entry>
</row>
<row>
  <entry>\t</entry>
  <entry>Tab character</entry>
</row>
</tbody>
</tgroup>
</table>

</section>

</chapter>

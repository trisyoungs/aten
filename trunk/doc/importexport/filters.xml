<section id="readwrite.filters"><title>Filters</title>
	<indexterm id="idx.readwrite.filters" class="startofrange"><primary>filters</primary></indexterm>
	
	<para>Filters determine the model/trajectory, grid/surface, and forcefield expression formats that Aten can read and write. They are essentially small programs written in the style of C, and are stored as plain text files (source files, if you like) on disk and loaded and 'compiled' when Aten starts up. This has several advantages:</para>
	
	<itemizedlist mark='opencircle'>
		<listitem>
			<para>Users may add support for their own particular formats at will.</para>
		</listitem>
		<listitem>
			<para>No recompilation of Aten is necessary when adding new filters or adjusting old ones</para>
		</listitem>
		<listitem>
			<para>Potentially any file format can be supported, even binary formats</para>
		</listitem>
	</itemizedlist>

	<para>With this flexibility, of course, comes some modest disadvantages:</para>
	
	<itemizedlist mark='opencircle'>
		<listitem>
			<para>Speed - although the C-style code contained within filters is 'compiled', it is by no means as fast as proper C code</para>
		</listitem>
		<listitem>
			<para>File formats that need particularly awkward operations requiring a more 'complete' C language may be difficult to implement</para>
		</listitem>
	</itemizedlist>
	
	<para>These two points aside, though, filters make Aten a powerful and flexible tool, adaptable to conform to many different program/code input and output formats.</para>
	
	<para>As mentioned, the programming language used by filters is essentially a subset of C, implemented with the same syntax and style (see <link linkend="command.overview">command language overview</link> for a description), but includes several hundred custom commands to control Aten in order to build up atoms in models, access data etc. So, if you already know C or C++, writing a filter should be a breeze. If you don't, its not too difficult to pick up, and there are plenty of filters already written to use as worked examples.</para>
	
	<para>When a filter is called in order to write out data, no references to any of the current (i.e. displayed or selected) data are sent directly to the filter itself. Instead, this must be probed by using the ((Paths and Subvariables|#Aten|aten master reference)) available to all scripts, commands and filters. Within ((Paths and Subvariables|#Aten|aten)) the currently displayed model may be deduced, as well as the current frame (if a trajectory is associated). In most cases for model export filters, the path 'aten.frame' should be used to determine the model data that should be written.</para>
	
	<section id="readwrite.filters.contents"><title>Filter Contents</title>
		<indexterm><primary>filters</primary><secondary>contents</secondary></indexterm>

		<para>A filter is a plain text file containing one or more C-style programs that permit the input or output of data in a specific format. For example, a purely model-oriented filter file may contain two filters, one to read in files of the specified format, and one to write the data out again. Each individual filter is given a short nickname, a shell-style glob, and possibly several other bits of data that allow files to be recognised (if the file extensions defined for it are not enough).</para>
	
		<para>Different filters that recognise the same file type may be provided if necessary, each performing a slightly different set of import or export commands (if it is not convenient to do so within a single filter), and all will appear in the drop-down list of filters in file dialogs within the program. Note that in batch, command-line, or scripting mode, filters are either selected automatically based on the filename, extension, or contents, or picked by matching only the associated nickname. In the former case, the first filter that matches the extension is used.</para>
	
	</section>
	
	<section id="readwrite.filters.locations"><title>Filter Locations</title>
		<indexterm><primary>filters</primary><secondary>locations</secondary></indexterm>

		<para>A basic stock of filters is provided with Aten and installed with the program - several default locations are searched for these filters on startup. Alternatively, if Aten fails to find these filters, or you wish to point it to a suitable directory by hand, either the $ATENDATA environment variable may be set to the relevant path (on Windows, this variable is set by the installer) or the <link linkend="cli.switches.atendata">--atendata</link> command-line option may be used to provide the path.</para>
	
		<para>Additional filters may be placed in a user's '.aten' directory, e.g. ~bob/.aten/filters/.</para>
		
	</section>
		
	<section id="readwrite.filters.overriding"><title>Overriding Existing Filters</title>
		<indexterm><primary>filters</primary><secondary>overriding</secondary></indexterm>

		<para>Filters that possess the same ID or nickname as other filters of the same type may be loaded simultaneously, with the last to be loaded taking preference over the other. Thus, an importmodel filter nicknamed 'xyz' from Aten's installed filter stock will be overridden by one of the same nickname present in a user's '.aten/filters' directory. Similarly, both these filters will be overridden by one of the same nickname loaded by hand from the command line (with the ((The Command Line|#--filter|--filter)) switch). Note that this only holds true for filters referenced by nickname or determined automatically by Aten when loading data - from the GUI all filters are available in the file dialogs.</para>
		
	</section>
	
	
<!-- 	!!#Example Filter -->
<!-- 	For a complete filter example (XMol XYZ Import / Export) with full descriptions of the inner workings, look at ((Filter XYZ)). -->
	
	<section id="readwrite.filters.definitions"><title>Filter Definitions</title>
		<indexterm><primary>filters</primary><secondary>defining</secondary></indexterm>
		
		<para>Filter definitions are made in a filter file in a similar way to declaring a <link linkend="command.overview.userfunctions">user subroutine or function</link>. The 'filter' keyword marks the start of a filter definition, and contains a list of properties in parentheses that define the subsequent filter, its name, and how to recognise the files (from their filenames and/or contents) that it is designed for. The definition of the filter to import XYZ-style model data is as follows:</para>
	
		<synopsis>
			filter(type=&quot;importmodel&quot;, name=&quot;XMol XYZ Coordinates&quot;, nickname=&quot;xyz&quot;, extension=&quot;xyz&quot;, glob=&quot;*.xyz&quot;, id=3)
			{
				<emphasis>commands</emphasis>
				...
			}
		</synopsis>
		
		<indexterm id="idx.readwrite.filters.properties" class="startofrange"><primary>filters</primary><secondary>properties</secondary></indexterm>
	
		<para>The comma-separated list of properties defines the type of filter ('type=&quot;importmodel&quot;') and how to recognise files of that type (e.g., 'extension=&quot;xyz&quot;'), amongst other things. The full list of possible properties is as follows:</para>
	
		<table frame='all' pgwide='1' tocentry='0'><title>Filter properties</title>
			<tgroup cols='2' align='left' colsep='1' rowsep='1'>
				<thead>
					<row>
						<entry>Property</entry>
						<entry>Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>exact</entry>
						<entry>Comma-separated list of filenames that are of this type</entry>
					</row>
					<row>
						<entry>extension</entry>
						<entry>Comma-separated list of filename extensions that indicate files of this type</entry>
					</row>
					<row>
						<entry>glob</entry>
						<entry>Shell-style glob to use in file fialogs in order to filter out files of the described type</entry>
					</row>
					<row>
						<entry>id</entry>
						<entry>Numerical ID of the filter to enable partnering of import/export filters for files of the same type</entry>
					</row>
					<row>
						<entry>name</entry>
						<entry>Descriptive name for the filter, shown in file dialogs etc.</entry>
					</row>
					<row>
						<entry>nickname</entry>
						<entry>Short name used by commands in order to identify specific filters</entry>
					</row>
					<row>
						<entry>search</entry>
						<entry>Provides a string to search for in the file. If the string is found, the file is identified as being readable by this filter type. The number of lines searched is governed by the <link linkend="readwrite.filters.properties.within">within</link> property</entry>
					</row>
					<row>
						<entry>type</entry>
						<entry>Defines the kind of filter that is described (i.e. if it loads/saves, acts on models/grid data etc.) so that Aten knows when to use it. <emphasis>Must always be defined!</emphasis></entry>
					</row>
					<row>
						<entry>within</entry>
						<entry>Specifies the number of lines to search for any supplied <link linkend="readwrite.filters.properties.search">search</link> strings</entry>
					</row>
					<row>
						<entry>zmap</entry>
						<entry>Determines which zmapping style to employ when converting atom names from the file</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
	
		<section id="readwrite.filters.properties.exact"><title>exact</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>exact</tertiary></indexterm>
			
			<para>Occasionally (and annoyingly) files have no extension at all, instead having short, fixed names, which must be checked for literally when probing files. This command defines one or more exact filenames that identify files to be acted on by this filter section. Multiple names may be given, separated by commas or whitespace. Exact filename matching is case-insensitive.</para>
			
			<para>For example:</para>
			<synopsis>
				exact=&quot;coords&quot;
			</synopsis>
			<para>associates any file called 'coords' to this filter.</para>
			<synopsis>
				exact=&quot;results,output&quot;
			</synopsis>
			<para>associates any files called 'results' or 'output' to this filter.</para>
			
		</section>
		
		<section id="readwrite.filters.properties.extension"><title>extension</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>extension</tertiary></indexterm>
			
			<para>Sets the filename extension(s) that identify files to be read / written by this filter. When files are being probed for their type, in the first instance the filename is examined and the extension (everything after the last '.') is compared to those defined in filter sections by this command. Multiple file extensions may be given, separated by commas or whitespace. File extension matching is case-insensitive.</para>
			
			<para>For example:</para>
			<synopsis>
				extension=&quot;xyz&quot;
			</synopsis>
			<para>means that files with extension '.xyz' will be recognised by this filter.</para>
			<synopsis>
				extension=&quot;xyz,abc,foo&quot;
			</synopsis>
			<para>means that files with extensions '.xyz', '.abc', and '.foo' will be recognised by this filter.</para>
	
		</section>
	
		<section id="readwrite.filters.properties.glob"><title>glob</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>glob</tertiary></indexterm>
	
			<para>Sets the file dialog filter extension to use in the GUI, and should be provided as a shell-style glob.</para>
	
			<para>For example:</para>
			<synopsis>
				glob=&quot;*.doc&quot;
			</synopsis>
			<para>filters any file matching '*.doc' in the relevant GUI file selector dialogs.</para>
	
		</section>
	
		<section id="readwrite.filters.properties.id"><title>id</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>id</tertiary></indexterm>

			<para>When separate import and export filters for a given file type have been provided it is prudent to associate the pair together so that Aten knows how to save the data that has just been loaded in. Each filter has a user-definable integer ID associated with it that can be used to link import and export filters together. For example, if a model import filter has an ID of 7, and a model export filter also has this ID, then it will be assumed that the two are linked, and that a model saved with export filter 7 can be subsequently loaded with import filter 7. If the ID for a filter is not set it defaults to -1, and it is assumed that no partner exists and the file cannot be directly saved back into this format.</para>
	
			<para>For example:</para>
			<synopsis>
				id=13
			</synopsis>
			
			<note><title>See Also:</title>
				<itemizedlist mark='opencircle'>
					<listitem>
						<para><link linkend="readwrite.supportedformats">Supported formats</link> to find out the list of currently-assigned ids</para>
					</listitem>
				</itemizedlist>
			</note>
	
		</section>
	
		<section id="readwrite.filters.properties.name"><title>name</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>name</tertiary></indexterm>
	
			<para>Sets the long name of the filter, to be used as the filetype description of files identified by the filter. This name will appear in the file type lists of file dialogs in the GUI, and also in the program output when reading / writing files of the type.</para>
	
			<para>For example:</para>
			<synopsis>
				name=&quot;SuperHartree Coordinates File&quot;
			</synopsis>
	
		</section>
	
		<section id="readwrite.filters.properties.nickname"><title>nickname</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>nickname</tertiary></indexterm>
	
			<para>Sets a nickname for the filter, which allows it to be identified easily in the command language and, importantly, from the command line. It should be a short name or mnemonic that easily identifies the filter. No checking is made to see if a filter using the supplied nickname already exists.</para>
	
			<para>For example:</para>
			<synopsis>
				nickname=&quot;shart&quot;
			</synopsis>
			<para>sets the nickname of the filter to 'shart'.</para>
			<synopsis>
				nickname=&quot;zyx&quot;
			</synopsis>
			<para>sets the nickname of the filter to 'zyx'.</para>
	
		</section>
	
		<section id="readwrite.filters.properties.search"><title>search</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>search</tertiary></indexterm>
			
			<para>Occasionally, checking the contents of the file is the easiest way to determining its type, and is probably of most use for the output of codes where the choice of filename for the results is entirely user-defined. For example, most codes print out a whole load of blurb and references at the very beginning, and usually searching for the program name within this region is enough to identify it. For files that are only easily identifiable from their contents and not their filename, plain text searches within files can be made to attempt to identify them. Individual strings can be given to the 'search' keyword, and multiple 'search' keywords can be provided. The default is to search the first 10 lines of the file for one or more of the defined search strings, but this can be changed with the <link linkend="readwrite.filters.properties.within">within</link> property.</para>
	
			<para>For example:</para>
			<synopsis>
				search=&quot;UberCode Version 20.0&quot;
			</synopsis>
			matches the filter to any file containing the string 'UberCode Version 20.0' within its first 10 lines (the default).</para>
			<synopsis>
				search=&quot;SIESTA&quot;
			</synopsis>
			<para>searches the first 10 lines of the file for the string 'SIESTA'.</para>
			{CODE()}search=&quot;&quot;GAMESS VERSION = 11 APR 2008 (R1)&quot;{CODE}
			<para>attempts to identify output from a specific version of GAMESS-US.</para>
	
		</section>
		
		<section id="readwrite.filters.properties.type"><title>type</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>type</tertiary></indexterm>

			<para>The 'type' keyword must be provided an all filter definitions - an error will be raised if it is not. It specifies which class of data the filter targets (e.g. models, grid data etc.) and whether it is an import or export filter. A given filter may only have one 'type'. The possible values for 'type' are:</para>
	
			<table frame='all' pgwide='1' tocentry='0'><title>Filter types</title>
				<tgroup cols='2' align='left' colsep='1' rowsep='1'>
					<thead>
						<row>
							<entry>Type</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>exportexpression</entry>
							<entry>Describes how to export forcefield descriptions (expressions) for models</entry>
						</row>
						<row>
							<entry>exportgrid</entry>
							<entry>Describes how to export grid-style data</entry>
						</row>
						<row>
							<entry>exportmodel</entry>
							<entry>Describes how to write out model data</entry>
						</row>
						<row>
							<entry>exporttrajectory</entry>
							<entry>Filter suitable for the export of trajectory data</entry>
						</row>
						<row>
							<entry>importexpression</entry>
							<entry>Describes how to load in forcefield-style expressions</entry>
						</row>
						<row>
							<entry>importgrid</entry>
							<entry>Describes how to read gridded volumetric or surface data from files. Any grids created in these sections must have the <link linkend="command.finalisegrid">finalisegrid</link> command called on them, otherwise they will not be registered properly within the program.</entry>
						</row>
						<row>
							<entry>importmodel</entry>
							<entry>Describes how to import model data, including atoms, cell and spacegroup data, bonds, glyphs etc. Any models created in 'importmodel' sections must have the <link linkend="command.finalisemodel">finalisemodel</link> command called on them, otherwise they will not be registered properly within the program.</entry>
						</row>
						<row>
							<entry>importtrajectory</entry>
							<entry>Read frames from trajectory files. See the section on <link linkend="readwrite.trajectories">trajectories</link> for additional information on how trajectories are handled within Aten.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
	
			<para>For example:</para>
			<synopsis>
				type=&quot;importgrid&quot;
			</synopsis>
			<synopsis>
				type=&quot;exportmodel&quot;
			</synopsis>
	
		</section>
		
		<section id="readwrite.filters.properties.within"><title>within</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>within</tertiary></indexterm>
			
			<para>Defines the number of lines to search for any 'search' string definitions (default is 10).</para>
	
			<para>For example:</para>
			<synopsis>
				within=50
			</synopsis>
			<para>specifies that the first 50 lines should be searched for identifying strings.</para>
	
		</section>
		
		<section id="readwrite.filters.properties.zmap"><title>zmap</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>zmap</tertiary></indexterm>
	
			<para>By default, it is assumed that the commands which create new atoms will be given a proper element symbol from which to determine the atomic number. Case is unimportant, so 'na', 'Na', and 'NA' will all be interpreted as atomic number 11 (sodium). Where element symbols are not used in the model file, there are several alternative options that tell these commands how to convert the element data they are passed into atomic numbers. For example, the 'ff' style is particularly useful when loading in coordinate files which contain forcefield atom type names that do not always correspond trivially to element information (e.g. DL_POLY configurations).</para>
	
			<para>For example:</para>
			<synopsis>
				zmap=&quot;numeric&quot;
			</synopsis>
			<para>indicates that atomic numbers are provided in place of element names and no conversion should be performed.</para>
			
			<note><title>See Also:</title>
				<itemizedlist mark='opencircle'>
					<listitem>
						<para><link linkend="enums.zmaptypes">ZMapping types</link> for a list of the available zmapping methods</para>
					</listitem>
				</itemizedlist>
			</note>
			
		</section>
		
	<indexterm id="idx.readwrite.filters.properties" class="startofrange"><primary>filters</primary><secondary>properties</secondary></indexterm>

	<indexterm startref="idx.readwrite.filters" class="endofrange"><primary>filters</primary></indexterm>
</section>
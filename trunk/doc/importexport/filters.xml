<section id="readwrite.filters"><title>Filters</title>
	<indexterm zone="readwrite.filters"><primary>filters</primary></indexterm>
	
	<para>Filters determine the model/trajectory, grid/surface, and forcefield expression formats that Aten can read and write. They are essentially small programs written in the style of C, and are stored as plain text files (source files, if you like) on disk and loaded and 'compiled' when Aten starts up. This has several advantages:</para>
	
	<itemizedlist mark='opencircle'>
		<listitem>
			<para>Users may add support for their own particular formats at will.</para>
		</listitem>
		<listitem>
			<para>No recompilation of Aten is necessary when adding new filters or adjusting old ones</para>
		</listitem>
		<listitem>
			<para>Potentially any file format can be supported, even binary formats</para>
		</listitem>
	</itemizedlist>

	<para>With this flexibility, of course, comes some modest disadvantages:</para>
	
	<itemizedlist mark='opencircle'>
		<listitem>
			<para>Speed - although the C-style code contained within filters is 'compiled', it is by no means as fast as proper C code</para>
		</listitem>
		<listitem>
			<para>File formats that need particularly awkward operations requiring a more 'complete' C language may be difficult to implement</para>
		</listitem>
	</itemizedlist>
	
	<para>These two points aside, though, filters make Aten a powerful and flexible tool, adaptable to conform to many different program/code input and output formats.</para>
	
	<para>As mentioned, the programming language used by filters is essentially a subset of C, implemented with the same syntax and style (see <link linkend="command.overview">command language overview</link> for a description), but includes several hundred custom commands to control Aten in order to build up atoms in models, access data etc. So, if you already know C or C++, writing a filter should be a breeze. If you don't, its not too difficult to pick up, and there are plenty of filters already written to use as worked examples.</para>
	
	<para>When a filter is called in order to write out data, no references to any of the current (i.e. displayed or selected) data are sent directly to the filter itself. Instead, this must be probed by using the <link linkend="command.types.aten">Aten master reference</link> available to all scripts, commands and filters. Within <link linkend="command.types.aten">&amp;aten</link> the currently displayed model may be deduced, as well as the current frame (if a trajectory is associated). In most cases for model export filters, the path 'aten.frame' should be used to determine the model data that should be written.</para>
	
	<section id="readwrite.filters.contents"><title>Filter Contents</title>
		<indexterm><primary>filters</primary><secondary>contents</secondary></indexterm>

		<para>A filter is a plain text file containing one or more C-style programs that permit the input or output of data in a specific format. For example, a purely model-oriented filter file may contain two filters, one to read in files of the specified format, and one to write the data out again. Each individual filter is given a short nickname, a shell-style glob, and possibly several other bits of data that allow files to be recognised (if the file extensions defined for it are not enough).</para>
	
		<para>Different filters that recognise the same file type may be provided if necessary, each performing a slightly different set of import or export commands (if it is not convenient to do so within a single filter), and all will appear in the drop-down list of filters in file dialogs within the program. Note that in batch, command-line, or scripting mode, filters are either selected automatically based on the filename, extension, or contents, or picked by matching only the associated nickname. In the former case, the first filter that matches the extension is used.</para>
	
	</section>
	
	<section id="readwrite.filters.locations"><title>Filter Locations</title>
		<indexterm><primary>filters</primary><secondary>locations</secondary></indexterm>

		<para>A basic stock of filters is provided with Aten and installed with the program - several default locations are searched for these filters on startup. Alternatively, if Aten fails to find these filters, or you wish to point it to a suitable directory by hand, either the $ATENDATA environment variable may be set to the relevant path (on Windows, this variable is set by the installer) or the <link linkend="cli.switches.atendata">--atendata</link> command-line option may be used to provide the path.</para>
	
		<para>Additional filters may be placed in a user's '.aten' directory, e.g. ~bob/.aten/filters/.</para>
		
	</section>
		
	<section id="readwrite.filters.overriding"><title>Overriding Existing Filters</title>
		<indexterm><primary>filters</primary><secondary>overriding</secondary></indexterm>

		<para>Filters that possess the same ID or nickname as other filters of the same type may be loaded simultaneously, with the last to be loaded taking preference over the other. Thus, an importmodel filter nicknamed 'xyz' from Aten's installed filter stock will be overridden by one of the same nickname present in a user's '.aten/filters' directory. Similarly, both these filters will be overridden by one of the same nickname loaded by hand from the command line (with the <link linkend="cli.switches.filter">--filter</link> switch). Note that this only holds true for filters referenced by nickname or determined automatically by Aten when loading data - from the GUI all filters are available in the file dialogs.</para>
		
	</section>
	
	
<!-- 	!!#Example Filter -->
<!-- 	For a complete filter example (XMol XYZ Import / Export) with full descriptions of the inner workings, look at ((Filter XYZ)). -->
	
	<section id="readwrite.filters.definitions"><title>Filter Definitions</title>
		<indexterm><primary>filters</primary><secondary>defining</secondary></indexterm>
		
		<para>Filter definitions are made in a filter file in a similar way to declaring a <link linkend="command.overview.userfunctions">user subroutine or function</link>. The 'filter' keyword marks the start of a filter definition, and contains a list of properties in parentheses that define the subsequent filter, its name, and how to recognise the files (from their filenames and/or contents) that it is designed for. The definition of the filter to import XYZ-style model data is as follows:</para>
	
		<synopsis>
filter(type=&quot;importmodel&quot;, name=&quot;XMol XYZ Coordinates&quot;, nickname=&quot;xyz&quot;, extension=&quot;xyz&quot;, glob=&quot;*.xyz&quot;, id=3)
{
	<emphasis>commands</emphasis>
	...
}
		</synopsis>
		
		<indexterm zone="readwrite.filters.definitions"><primary>filters</primary><secondary>properties</secondary></indexterm>
	
		<para>The comma-separated list of properties defines the type of filter ('type=&quot;importmodel&quot;') and how to recognise files of that type (e.g., 'extension=&quot;xyz&quot;'), amongst other things. The full list of possible properties is as follows:</para>
	
		<table frame='all' pgwide='1' tocentry='0'><title>Filter properties</title>
			<tgroup cols='2' align='left' colsep='1' rowsep='1'>
				<thead>
					<row>
						<entry>Property</entry>
						<entry>Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>exact</entry>
						<entry>Comma-separated list of filenames that are of this type</entry>
					</row>
					<row>
						<entry>extension</entry>
						<entry>Comma-separated list of filename extensions that indicate files of this type</entry>
					</row>
					<row>
						<entry>glob</entry>
						<entry>Shell-style glob to use in file fialogs in order to filter out files of the described type</entry>
					</row>
					<row>
						<entry>id</entry>
						<entry>Numerical ID of the filter to enable partnering of import/export filters for files of the same type</entry>
					</row>
					<row>
						<entry>name</entry>
						<entry>Descriptive name for the filter, shown in file dialogs etc.</entry>
					</row>
					<row>
						<entry>nickname</entry>
						<entry>Short name used by commands in order to identify specific filters</entry>
					</row>
					<row>
						<entry>search</entry>
						<entry>Provides a string to search for in the file. If the string is found, the file is identified as being readable by this filter type. The number of lines searched is governed by the <link linkend="readwrite.filters.properties.within">within</link> property</entry>
					</row>
					<row>
						<entry>type</entry>
						<entry>Defines the kind of filter that is described (i.e. if it loads/saves, acts on models/grid data etc.) so that Aten knows when to use it. <emphasis>Must always be defined!</emphasis></entry>
					</row>
					<row>
						<entry>within</entry>
						<entry>Specifies the number of lines to search for any supplied <link linkend="readwrite.filters.properties.search">search</link> strings</entry>
					</row>
					<row>
						<entry>zmap</entry>
						<entry>Determines which zmapping style to employ when converting atom names from the file</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
	
		<section id="readwrite.filters.properties.exact"><title>exact</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>exact</tertiary></indexterm>
			
			<para>Occasionally (and annoyingly) files have no extension at all, instead having short, fixed names, which must be checked for literally when probing files. This command defines one or more exact filenames that identify files to be acted on by this filter section. Multiple names may be given, separated by commas or whitespace. Exact filename matching is case-insensitive.</para>
			
			<para>For example:</para>
			<synopsis>
exact=&quot;coords&quot;
			</synopsis>
			<para>associates any file called 'coords' to this filter.</para>
			<synopsis>
exact=&quot;results,output&quot;
			</synopsis>
			<para>associates any files called 'results' or 'output' to this filter.</para>
			
		</section>
		
		<section id="readwrite.filters.properties.extension"><title>extension</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>extension</tertiary></indexterm>
			
			<para>Sets the filename extension(s) that identify files to be read / written by this filter. When files are being probed for their type, in the first instance the filename is examined and the extension (everything after the last '.') is compared to those defined in filter sections by this command. Multiple file extensions may be given, separated by commas or whitespace. File extension matching is case-insensitive.</para>
			
			<para>For example:</para>
			<synopsis>
extension=&quot;xyz&quot;
			</synopsis>
			<para>means that files with extension '.xyz' will be recognised by this filter.</para>
			<synopsis>
extension=&quot;xyz,abc,foo&quot;
			</synopsis>
			<para>means that files with extensions '.xyz', '.abc', and '.foo' will be recognised by this filter.</para>
	
		</section>
	
		<section id="readwrite.filters.properties.glob"><title>glob</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>glob</tertiary></indexterm>
	
			<para>Sets the file dialog filter extension to use in the GUI, and should be provided as a shell-style glob.</para>
	
			<para>For example:</para>
			<synopsis>
glob=&quot;*.doc&quot;
			</synopsis>
			<para>filters any file matching '*.doc' in the relevant GUI file selector dialogs.</para>
	
		</section>
	
		<section id="readwrite.filters.properties.id"><title>id</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>id</tertiary></indexterm>

			<para>When separate import and export filters for a given file type have been provided it is prudent to associate the pair together so that Aten knows how to save the data that has just been loaded in. Each filter has a user-definable integer ID associated with it that can be used to link import and export filters together. For example, if a model import filter has an ID of 7, and a model export filter also has this ID, then it will be assumed that the two are linked, and that a model saved with export filter 7 can be subsequently loaded with import filter 7. If the ID for a filter is not set it defaults to -1, and it is assumed that no partner exists and the file cannot be directly saved back into this format.</para>
	
			<para>For example:</para>
			<synopsis>
id	=13
			</synopsis>
			
			<note><title>See Also:</title>
				<itemizedlist mark='opencircle'>
					<listitem>
						<para><link linkend="readwrite.supportedformats">Supported formats</link> to find out the list of currently-assigned ids</para>
					</listitem>
				</itemizedlist>
			</note>
	
		</section>
	
		<section id="readwrite.filters.properties.name"><title>name</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>name</tertiary></indexterm>
	
			<para>Sets the long name of the filter, to be used as the filetype description of files identified by the filter. This name will appear in the file type lists of file dialogs in the GUI, and also in the program output when reading / writing files of the type.</para>
	
			<para>For example:</para>
			<synopsis>
name=&quot;SuperHartree Coordinates File&quot;
			</synopsis>
	
		</section>
	
		<section id="readwrite.filters.properties.nickname"><title>nickname</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>nickname</tertiary></indexterm>
	
			<para>Sets a nickname for the filter, which allows it to be identified easily in the command language and, importantly, from the command line. It should be a short name or mnemonic that easily identifies the filter. No checking is made to see if a filter using the supplied nickname already exists.</para>
	
			<para>For example:</para>
			<synopsis>
nickname=&quot;shart&quot;
			</synopsis>
			<para>sets the nickname of the filter to 'shart'.</para>
			<synopsis>
nickname=&quot;zyx&quot;
			</synopsis>
			<para>sets the nickname of the filter to 'zyx'.</para>
	
		</section>
	
		<section id="readwrite.filters.properties.search"><title>search</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>search</tertiary></indexterm>
			
			<para>Occasionally, checking the contents of the file is the easiest way to determining its type, and is probably of most use for the output of codes where the choice of filename for the results is entirely user-defined. For example, most codes print out a whole load of blurb and references at the very beginning, and usually searching for the program name within this region is enough to identify it. For files that are only easily identifiable from their contents and not their filename, plain text searches within files can be made to attempt to identify them. Individual strings can be given to the 'search' keyword, and multiple 'search' keywords can be provided. The default is to search the first 10 lines of the file for one or more of the defined search strings, but this can be changed with the <link linkend="readwrite.filters.properties.within">within</link> property.</para>
	
			<para>For example:</para>
			<synopsis>
search=&quot;UberCode Version 20.0&quot;
			</synopsis>
			<para>matches the filter to any file containing the string 'UberCode Version 20.0' within its first 10 lines (the default).</para>
			<synopsis>
search=&quot;SIESTA&quot;
			</synopsis>
			<para>searches the first 10 lines of the file for the string 'SIESTA'.</para>
			<synopsis>
search=&quot;&quot;GAMESS VERSION = 11 APR 2008 (R1)&quot;
			</synopsis>
			<para>attempts to identify output from a specific version of GAMESS-US.</para>
	
		</section>
		
		<section id="readwrite.filters.properties.type"><title>type</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>type</tertiary></indexterm>

			<para>The 'type' keyword must be provided an all filter definitions - an error will be raised if it is not. It specifies which class of data the filter targets (e.g. models, grid data etc.) and whether it is an import or export filter. A given filter may only have one 'type'. The possible values for 'type' are:</para>
	
			<table frame='all' pgwide='1' tocentry='0'><title>Filter types</title>
				<tgroup cols='2' align='left' colsep='1' rowsep='1'>
					<thead>
						<row>
							<entry>Type</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>exportexpression</entry>
							<entry>Describes how to export forcefield descriptions (expressions) for models</entry>
						</row>
						<row>
							<entry>exportgrid</entry>
							<entry>Describes how to export grid-style data</entry>
						</row>
						<row>
							<entry>exportmodel</entry>
							<entry>Describes how to write out model data</entry>
						</row>
						<row>
							<entry>exporttrajectory</entry>
							<entry>Filter suitable for the export of trajectory data</entry>
						</row>
						<row>
							<entry>importexpression</entry>
							<entry>Describes how to load in forcefield-style expressions</entry>
						</row>
						<row>
							<entry>importgrid</entry>
							<entry>Describes how to read gridded volumetric or surface data from files. Any grids created in these sections must have the <link linkend="command.ref.finalisegrid">finalisegrid</link> command called on them, otherwise they will not be registered properly within the program.</entry>
						</row>
						<row>
							<entry>importmodel</entry>
							<entry>Describes how to import model data, including atoms, cell and spacegroup data, bonds, glyphs etc. Any models created in 'importmodel' sections must have the <link linkend="command.ref.finalisemodel">finalisemodel</link> command called on them, otherwise they will not be registered properly within the program.</entry>
						</row>
						<row>
							<entry>importtrajectory</entry>
							<entry>Read frames from trajectory files. See the section on <link linkend="readwrite.trajectories">trajectories</link> for additional information on how trajectories are handled within Aten.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
	
			<para>For example:</para>
			<synopsis>
type=&quot;importgrid&quot;
			</synopsis>
			<synopsis>
type=&quot;exportmodel&quot;
			</synopsis>
	
		</section>
		
		<section id="readwrite.filters.properties.within"><title>within</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>within</tertiary></indexterm>
			
			<para>Defines the number of lines to search for any 'search' string definitions (default is 10).</para>
	
			<para>For example:</para>
			<synopsis>
within=50
			</synopsis>
			<para>specifies that the first 50 lines should be searched for identifying strings.</para>
	
		</section>
		
		<section id="readwrite.filters.properties.zmap"><title>zmap</title>
			<indexterm><primary>filters</primary><secondary>properties</secondary><tertiary>zmap</tertiary></indexterm>
	
			<para>By default, it is assumed that the commands which create new atoms will be given a proper element symbol from which to determine the atomic number. Case is unimportant, so 'na', 'Na', and 'NA' will all be interpreted as atomic number 11 (sodium). Where element symbols are not used in the model file, there are several alternative options that tell these commands how to convert the element data they are passed into atomic numbers. For example, the 'ff' style is particularly useful when loading in coordinate files which contain forcefield atom type names that do not always correspond trivially to element information (e.g. DL_POLY configurations).</para>
	
			<para>For example:</para>
			<synopsis>
zmap=&quot;numeric&quot;
			</synopsis>
			<para>indicates that atomic numbers are provided in place of element names and no conversion should be performed.</para>
			
			<note><title>See Also:</title>
				<itemizedlist mark='opencircle'>
					<listitem>
						<para><link linkend="enums.zmaptypes">ZMapping types</link> for a list of the available zmapping methods</para>
					</listitem>
				</itemizedlist>
			</note>
			
		</section>
		
	</section>

	<section id="readwrite.filters.options"><title>Filter Options</title>
		<indexterm><primary>filters</primary><secondary>options</secondary></indexterm>
		
		<para>When writing data, in many cases all the information that the filter wants to write is contained within the current model, for example when outputting simple file formats such as xyz or Aten's own akf. In other cases ther may be additional data for which would be nice to have some control over, and which lays beyond atoms and bondes. The best example is probably the input formats for nearly all <emphasis>ab initio</emphasis> codes which contain (as well as the atomic coordinates) statements and additional data necessary to control the running of the code itself. It is not a problem to write out 'static' lines of control commands from the output filter, but it would of course also be nice to be able to tailor this output from within the GUI (or from the command-line). This can be achieved by assigning values to variables in the filter through the use of filter options.</para>

		<para>Any number of options can be defined, and some relatively simple but useful control over the layout of the related GUI controls is possible.</para>

		<sect5 id="readwrite.filters.options.defining"><title>Defining Options</title>
		<indexterm><primary>filters</primary><secondary>options</secondary><tertiary>defining</tertiary></indexterm>
		<indexterm><primary>commands</primary><secondary>option</secondary></indexterm>

			<para>A filter option is defined in the following way within a filter file:</para>
				
			<synopsis>
<emphasis>vartype</emphasis> <emphasis>var</emphasis> = option(string <emphasis>name</emphasis>, string <emphasis>type</emphasis>, ...);
			</synopsis>
			
			<para>The specified <emphasis>name</emphasis> is the text that will appear next to the control in the GUI. The <emphasis>type</emphasis> of control governs the type of GUI widget that will appear (see the list of <link linkend="readwrite.filters.options.types">types</link> below). Following these two mandatory specifications, any required values must then be given in the correct order, after which any other non-control-specific options may be given, each surrounded by quote marks and in the format 'option' or 'option=value'. All of these are to do with the layout of controls (see the <link linkend="readwrite.filters.options.layout">option layout</link> section).</para>
				
			<para>For example, we we can set a string variable with one of several possible values using a combo box control in the GUI. When saving a file in a new format (or by selecting 'Export Options' from the 'File' menu) a dialog is shown in the GUI which contains all of the defined controls in the relevant filter, from which options can be set before the file is written. This would be written as follows in the filter file:</para>

			<synopsis>
string runtype = option(&quot;"Run Type"&quot;, &quot;"combo"&quot;, &quot;check,run,restart,analyse&quot;, 2);
			</synopsis>
		
			<para>Note that when the filter code actually runs, the target variable 'runtype' will be set with whatever value the control holds in the GUI (or the default if running from the command-line) - no questions are asked interactively at the points at which the 'option()' commands exist. So, the variable here will be guaranteed to take on one of the possible values 'check', 'run', 'restart', or 'analyse'.</para>

		</sect5>

		<sect5 id="readwrite.filters.options.types"><title>Option Types</title>
		<indexterm><primary>filters</primary><secondary>options</secondary><tertiary>types</tertiary></indexterm>

			<para>All available control types are listed in the following table. Note that <emphasis>all</emphasis> of the required data items must be given as arguments following the control type string in the <link linkend="command.ref.options">options</link>.</para>
			
			<table frame='all' pgwide='1' tocentry='0'><title>Option Types</title>
				<tgroup cols='3' align='left' colsep='1' rowsep='1'>
					<thead>
						<row>
							<entry>Type</entry>
							<entry>Required Data</entry>
							<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry>check</entry>
							<entry>int state = <emphasis>0 or 1</emphasis></entry>
							<entry>A checkbox whose state is either off or on. Returns an integer value ('1' if the control is ticked, '0' otherwise).</entry>
						</row>
						<row>
							<entry morerows='1'>combo</entry>
							<entry>string items = "<emphasis>item1,item2,...</emphasis>"</entry>
							<entry morerows='1'>A combobox is a drop-down list of predefined items. The text of the selected item is returned.</entry>
						</row>
						<row><entry>int default = 1-<emphasis>nitems</emphasis></entry></row>
						<row>
							<entry morerows='3'>doublespin</entry>
							<entry>double min</entry>
							<entry morerows='3'>Control allowing a real number to be input, strictly within the min/max range, and with start value specified. Up/down arrows to the side of the control adjust the current value by the 'step' value. A real number is returned.</entry>
						</row>
						<row><entry>double max</entry></row>
						<row><entry>double start</entry></row>
						<row><entry>double step</entry></row>
						<row>
							<entry>edit</entry>
							<entry></entry>
							<entry></entry>
						</row>
						<row>
							<entry morerows='1'>intcombo</entry>
							<entry>string items = "<emphasis>item1,item2,...</emphasis>"</entry>
							<entry morerows='1'>Exactly the same as the 'combo' control above, but instead returns an integer value corresponding to the index of the selected entry.</entry>
						</row>
						<row><entry>int default = 1-<emphasis>nitems</emphasis></entry></row>
						<row>
							<entry morerows='3'>intspin</entry>
							<entry>int min</entry>
							<entry morerows='3'>Control allowing an integer number to be input, strictly within the min/max range, and with start value specified. Up/down arrows to the side of the control adjust the current value by the 'step' value. An integer number is returned.</entry>
						</row>
						<row><entry>int max</entry></row>
						<row><entry>int start</entry></row>
						<row><entry>int step</entry></row>
						<row>
							<entry>label</entry>
							<entry>None.</entry>
							<entry>A simple text label, with no associated value.</entry>
						</row>
						<row>
							<entry morerows='1'>radio</entry>
							<entry>string group</entry>
							<entry morerows='1'>A radio control is part of a set of checkable items, of which only one can be selected at any one point. The parent group does not need to be created beforehand - if the named group does not currently exist, it will be created. Note that the group widget itself is not visible, and so many contain any number of radio buttons spread over many tabs and pages.</entry>
						</row>
						<row><entry>int checked</entry></row>
						<row>
							<entry>radiogroup</entry>
							<entry>None.</entry>
							<entry>A radio group is a collection of radio buttons, of which only one can be selected at any one time. A radiogroup only provides the means to collect a set of radio buttons together, and it not itself visible. The index of the selected item is returned.</entry>
						</row>
						<row>
							<entry>stringradiogroup</entry>
							<entry>None.</entry>
							<entry>Same as 'radiogroup', except that the text label of the selected item is returned.</entry>
						</row>
					</tbody>
				</tgroup>
			</table>

		</sect5>

		<sect5 id="readwrite.filters.options.layout"><title>Option Layout</title>
		<indexterm><primary>filters</primary><secondary>options</secondary><tertiary>layout</tertiary></indexterm>

		<para>The layout of specified GUI controls is done in as simplistic a manner as possible, while still offering reasonable control over the positioning of elements. If no layout options are specified, all defined controls will be added one after the other in a single row, left-to-right, possibly stretching further than the screen can handle. At the very least, the 'newline' command should be used to force a control option to start a new 'row' of controls in the GUI. All controls are added into a grid (Qt's QGridLayout) so that controls always line up nicely. It is also possible to group controls together in tabbed widgets and group boxes.</para>
		
		<para>All controls (except the plain label) are two 'units' wide on the grid, and this should be borne in mind when stretching a single control to be the same width as a set of controls on a different row.</para>
		
		<table frame='all' pgwide='1' tocentry='0'><title>Layout Commands</title>
			<tgroup cols='3' align='left' colsep='1' rowsep='1'>
				<thead>
					<row>
						<entry>Option</entry>
						<entry>Value</entry>
						<entry>Description</entry>
					</row>
				</thead>
				<tbody>
					<row>
						<entry>centre</entry>
						<entry><emphasis>none</emphasis></entry>
						<entry>By default, all labels are right-aligned so they sit next to their associated controls. This forces the label to be aligned in the centre instead.</entry>
					</row>
					<row>
						<entry>disabled</entry>
						<entry><emphasis>none</emphasis></entry>
						<entry>All controls are enabled by default. Specifying 'disabled' will gray-out the control.</entry>
					</row>
					<row>
						<entry>group</entry>
						<entry>name</entry>
						<entry>To place controls inside a groupbox instead of just adding them to the window the 'group' property can be set. For instance, to add a control to a group box called 'Run Options' you can specify 'group=Run Options' as an argument. Note that the group name is displayed as the title of the group in the GUI. If the named group box does not exist then it is created in the next available position (i.e. after the last created control). Otherwise, the control is added to the existing group box in the next available position.</entry>
					</row>
					<row>
						<entry>labelspan</entry>
						<entry>ncols</entry>
						<entry>A label takes up a single column by default. The 'labelspan' property can be set to override this. For example, adding 'labelspan=4' to the list of arguments will force the label to span four columns instead of one.</entry>
					</row>
					<row>
						<entry>left</entry>
						<entry><emphasis>none</emphasis></entry>
						<entry>By default, all labels are right-justified so they sit next to their associated controls. This forces the label to be aligned to the left instead.</entry>
					</row>
					<row>
						<entry>newline</entry>
						<entry><emphasis>none</emphasis></entry>
						<entry>All controls are added to the immediate right of the last control created, unless the 'newline' command is given. Then, the control will be added at the beginning of a new row.</entry>
					</row>
					<row>
						<entry>parentspan</entry>
						<entry>ncols</entry>
						<entry>A group box or tab control takes up a single column by default. The 'parentspan' property can be set to override this at the time of creation of the group/tab control. For example, adding 'parentspan=2' to the list of arguments will force the group box or tab widget to span two columns instead of one.</entry>
					</row>
					<row>
						<entry>span</entry>
						<entry>ncols</entry>
						<entry>All controls take up a single column by default. The 'span' property can be set to override this. For example, adding 'span=5' to the list of arguments will force the control to span five columns instead of one. The associated label will still use only one column, unless this is overridden by the 'labelspan' property.</entry>
					</row>
					<row>
						<entry>state</entry>
						<entry>value@name?action</entry>
						<entry>Some control over the states / content of other controls is possible using the 'state' command. The 'value' part indicates when the change detailed in 'action' is performed on the control 'name'. Since a direct equality comparison between the current value of the control and the state-change 'value' is made, only integer and string values make sense here. The control 'name' is the target control for the specified 'action', where 'action' is one of 'checked', 'disable', 'enable', 'items', or 'originalitems'. For those actions that take a property value (e.g. 'checked') the format of the line is then 'value@name?action=property'.</entry>
					</row>
					<row>
						<entry>tab</entry>
						<entry>page@name</entry>
						<entry>Similar to the 'group' command, this adds the widget to an existing page in an existing tab widget, or creates one or both and adds it there. For example, to add a control to a page named "Extra" in a tab widget called "My Tabs", you can specify 'tab=Extra@My Tabs' as an argument.</entry>
					</row>
				</tbody>
			</tgroup>
		</table>
		
		</sect5>
	
	</section>

</section>

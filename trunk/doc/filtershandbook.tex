\chapter{Filters Handbook}
\label{sec:filterhandbook}

\index{filters|(}
Filters are essentially just a series of text commands describing the format and structure of data in an arbitrary file. Plug-ins, if you like. While this might seem needlessly complex and a lot of extra work, for a little effort your (personal or enforced) favourite formats can be added to the program. The reward is a set of coordinates that can be thrown straight in to your code of choice. No support for writing out commands relevant to the running of calculations is provided, for three principal reasons:

\begin{enumerate}
	\item Input to codes is complicated, and I don't want to spend my evenings putting down endless combo boxes and spin buttons to cater for every basis set / method / obscure sub-option available.
	\item Putting commands in is best left for the user to do by hand, since there's no better way to learn the ins and outs of a code than to write commands, make mistakes, and be forced into the manual.
	\item The focus of \progname{} is on generating coordinates, pure and simple.
\end{enumerate}

But enough ranting! A filter contains (in order to be useful) sets of commands which describe how a file should be imported or exported from the program, and encompasses model files, forcefields, and trajectory files. However, different filters for the same file type may be provided if necessary, each performing a slightly different set of import or export commands (if it is convenient not do to so within a single filter), and all will appear in the drop-down list of filters in file dialogs within the program. Note that in batch, command-line, or scripting mode, filters are either selected automatically based on the filename, extension, or contents, or picked by matching only the associated nickname. In the former case, the first filter that matches the extension is used.\\

Filters are stored in one of two locations -- in a stock common to all users (as determined by the --prefix variable, or in the default location), and in \$HOME/.aten/filters. In both locations the filters read in by the program must be listed in the 'index' file -- if you create your own, you must add them to the index file for them to be loaded in on startup.\\

Read on and discover how to enable input / output of \qte{stuff} as you see fit. The following sections discuss the different aspects of filters and the types of file content that filters can be applied to, including examples. Although many of the commands are common to all of them, examples are good!

\subsection{Sections}
\index{filter!sections}
Commands to read / write different things are split up into sections within a filter file. You can specify as many filters as you like in any one file, each acting on a different set of models / forcefields / trajectories, etc., but it probably makes sense to have one file per model format where possible. All filter commands must be givin within one of these sections.

\begin{description}

	\item[importmodel\its]
	\index{filter commands!importmodel}
	Describes how to read model data from files, including atoms, cell and spacegroup data, and bonds.
	No variables are prepared by the command. Variables used after the command has completed:
	\begin{description}
		\item[$title$\its]
			Used to set the new title of the model.
		\item[$sg.group$ and $sg.setting$\its]
			Set the spacegroup and optionally the spacegroup setting so crystal packing can be performed.
	\end{description}

	\item[exportmodel\its]
	\index{filter commands!exportmodel}
	Write model data to files, including atoms, cell and spacegroup data, and bonds.\\
	Variables prepared by the command:
	\begin{description}
		\item[$title$\its]
			Title of the model.
		\item[$natoms$\its]
			Number of atoms in the model.
		\item[$cell.type$\its]
			Geometry of unit cell, one of \qte{none}, \qte{cubic}, \qte{orthorhombic}, or \qte{parallelepiped}.
		\item[$cell.x$, $cell.y$, $cell.z$\its]
			Lengths of the principal cell axes (if one is defined).
		\item[$cell.alpha$, $cell.beta$, $cell.gamma$\its]
			Angles between the principal cell axes (if one is defined).
		\item[$cell.xx$, $cell.xy$, $cell.xz$]
		\item[$cell.yx$, $cell.yy$, $cell.yz$]
		\item[$cell.zx$, $cell.zy$, $cell.zz$\its]
			Vector components of the unit cell matrix (if one is defined).
	\end{description}

	\item[trajectory]
	\index{filter commands!trajectory}
	Read trajectory files. Note that, since trajectory files often consist of a short descriptive header followed by frames listed end to end afterwards, 
	Variables prepared by the command:
	\begin{description}
		\item[$natoms$\its]
			Number of atoms in the model.
		\item[$cell.type$\its]
			Geometry of unit cell, one of \qte{none}, \qte{cubic}, \qte{orthorhombic}, or \qte{parallelepiped}.
	\end{description}

	\item[frame]
	\index{filter commands!frame}
	Read trajectory frame.\\
	Variables prepared by the command:
	\begin{description}
		\item[$natoms$\its]
			Number of atoms in the model.
		\item[$celltype$\its]
			Geometry of unit cell, one of \qte{none}, \qte{cubic}, \qte{orthorhombic}, or \qte{parallelepiped}.
	\end{description}

	\item[field]
	\index{filter commands!field}
	Write forcefield dsecription of current model.\\
	Variables set by the command:
	\begin{description}
		\item[$energyunit$\its]
			The current internal energy unit of the program, and hence the units used in the forcefield parameters.
		\item[$title$\its]
			Current title of the model.
		\item[$npatterns$\its]
			Number of different molecular species (pattern elements) in the model.
	\end{description}

\end{description}

\section{Recognising Files}
\label{sec:filterrecog}
\index{filters!recognising files}

Filters need a name. They are lonely creatures, and as such seek an identity. Although it can appear at more or less any point in the filter description, it usually makes most sense to name it early on. Consequently, the first line in most filters will be a short name describing what type of files the filter acts on:

\index{filter commands!name}
\begin{verbatim}
	name "ChikaanMol Coordinates File"
\end{verbatim}

This name will appear in the filter list of file dialogs in the GUI, and also in the program output when reading / writing files of the type. The next obvious question might be \dqte{How does the filter actually $recognise$ files of this type?} First off, there's the traditional way by filename extension:

\index{filter commands!extension}
\begin{verbatim}
	extension chik
\end{verbatim}

When files are being probed for their type, in the first instance the filename is examined and the extension (everything after the last \qte{.}) is compared to those defined in the filters. So, the example here would match all files ending with \qte{.ucf}. Sometimes one extension is not enough and there might be others that are used for the same type of file:

\begin{verbatim}
	extension "chik,egg,duk"
\end{verbatim}

Commas separate extensions, and the double-quotes are important to prevent \progname{} from interpreting the list as a list of arguments instead. Note that the comparison of filename extensions is case-insensitive, so \qte{.chk}, \qte{.EGG}, and \qte{.dUK} will all be matched by this filter.\\

Occasionally (and annoyingly) files have no extension at all, instead having short, fixed names. These exact names can be matched by the filter:

\index{filter commands!exact}
\begin{verbatim}
	exact config
\end{verbatim}

Exact filename matches are also case-insensitive, and lists of potential matches can be given, as before:

\begin{verbatim}
	exact "config,configuration,coordinates"
\end{verbatim}

Thirdly, the type of file can be matched by the contents of the file, and is probably of most use for the output of codes where the choice of filename for the results is entirely user-defined. For example, most codes print out a whole load of blurb and references at the very beginning, and usually searching for the program name within this region is enough:

\index{filter commands!within}
\begin{verbatim}
	within 10 "ChikaanMol version 2.2"
\end{verbatim}

This states that if the phrase \dqte{ChikaanMol version 2.2} can be found somewhere within the first 10 lines of the file, then the file is a match for this filter. One or more of the above criteria can be given, but it only takes a match with one of them to determine the type of file -- that is, they are not logically ANDed together.\\

All of the above is relevant to filters that import data. For exporting, \qte{exact} property is unused, but all others are relevant. When saving data without the aid of the GUI, the desired filter is specified through the use of a short nickname instead of by aspects of the filename, to avoid ambiguity.

\index{filter commands!nickname}
\begin{verbatim}
	nickname chikaan
\end{verbatim}

Used in an \qte{exportmodel} section, this allows one to specify the saving of data in the ubiquitous ChikaanMol coordinates format. In summary, use \qte{name}, \qte{extension}, and \qte{filter} in all sections, \qte{exact} (optionally) for filters that import data, and \qte{nickname} for filters that export data.

\section{Getting Data -- Format Strings}

So, now the file has been recognised, what happens next? We either read data in, or write data out. Enter \qte{format strings}. In nearly every way like FORMATs in Fortran and C/C++ $printf$ formats, these provide the interface to pass data between files and the program, and the sequence of commands is almost exactly like you would do in either of these programming languages. But for the uninitiated, don't panic! It's dead easy. Of course, in either language you use variables to store the data in the interim, and within filters this is no different. The basic (sub)processes in a filter are:

\begin{enumerate}
	\item Read data from a file.
	\item Split (parse) data into a number of variables.
	\item Tell \progname{} to act on the current values of variables.
\end{enumerate}

Variables thus form the bulk of the interface layer between numbers in a file, a filter to read them, and a program to use them (read--parse--act model). There are a handful of what you might call \qte{recognised} variables that mean something to the program in some way or other, but you are free to define your own at will to aid in the process of deconvoluting atomic data in awkward formats. See Section \ref{sec:variables} for a long waffle about variables in \progname{}. For now it is enough to know that variables are either generic character strings (converted to real or integer numbers as and when necessary) or special types such as, for example, references to atoms or patterns within the model. They are not declared at the beginning of the filter, instead being dynamically created and typed when they are required. All must begin with a \qte{\$} symbol to distinguish them from commands or plain text arguments to commands.

To demonstrate how these variables are used, lets assume that you have a file which is, for argument's sake, a coordinates file that has in it the following data:

\begin{verbatim}
Na      0.0     1.0     0.0
Cl      1.0     0.0     0.0
Na      0.0    -1.0     0.0
\end{verbatim}

Simply, elements and coordinates. Assuming that there's a filter command called \qte{readline} (there is) that reads in a line from a file and splits up the data on the line into a list of variables that you provide, if you were writing a command to describe one line of this data you would just say:

\begin{verbatim}
	readline "e r.x r.y r.z"
\end{verbatim}

The quoted part of the command is considered as the $format string$, and each element within it denotes a variable. After the command has completed, within the filter you can access the first item on the line that was read in by referencing the variable \qte{e}, the second with \qte{r.x}, and so on. These variables are all properties of an atom, but how do they actually become an atom? Well, these four are examples of so-called \qte{recognised} variables -- ones that the program looks for when storing or retrieving data (which depends on whether the filter itself is importing or exporting data). The command to create a new atom in the model we're currently reading in is \qte{addatom}, which, when run, looks for a number of specific variables from which to take data to set the properties of the new atom. In our example, it will find the variables \qte{e}, \qte{r.x}, \qte{r.y}, and \qte{r.z} and use them to set the element number and coordinates (it will also look for other variables which we have \textbf{not} set to any values, but won't complain when it can't find them). The situation is similar for other aspects of the model ($e.g.$ the unit cell), as well as for when we are writing data to a file instead of reading it -- the reverse process occurs, where we select an atom from the model (which sets the relevant variables) and then write out data using a format string containing these variables. \\

Lists of variables used or set by the various filter commands are given in the command reference in Section \ref{sec:filtercmds}. Also, see the chapter on variables (Section \ref{sec:variables}) for a full description and for details on how to specify the character length to read in, etc.


\subsection{Example -- XMol XYZ}
\label{sec:filterex1}
As always, things are best illustrated with an example. Take the XYZ format as popularised by XMol -- multiple models may be contained within a single file, each having a fixed structure with three basic data records:

\begin{enumerate}
  \item Number of atoms (1 line) -- Integer value specifying the number of atoms ($N$).
  \item Title (1 line) -- Long name or description of the system.
  \item Atom data ($N$ lines) -- Atom data, one per line, usually containing an aotomic element and its coordinates, but occasionally the atomic charge as well.
\end{enumerate}

For example:

\begin{verbatim}
3
Water
O     0.271   0.912   0.961    -0.8
H     0.978   1.244   1.295     0.4
H     0.126   0.149   1.307     0.4
\end{verbatim}

The corresponding filter can utilise the number of atoms provided in the file to read in the atom data, but this is not a general requirement since arbitrary loops can be defined to read in data until a certain point in the file (e.g. until a certain string is found, or simply until the end of the file is reached). The fully-specified filter (providing both import and export capabilities) for this type of file can be written as:

\begin{verbatim}
import
  name "XMol XYZ"
  extension xyz
  nickname xyz
  glob *.xyz
  readline "$natoms"
  readline "$title@100"
  repeat $n $natoms
    readline "$e $r.x $r.y $r.z $q"
    addatom
  end
  rebond
end
export
  name "XMol XYZ"
  glob *.xyz
  nickname xyz
  writeline "$natoms"
  writeline "$title"
  foratoms $i
    get $i
    writeline "$i.e@3 *@4 $i.r.x@12 $i.r.y@12 $i.r.z@12"
  end
end
\end{verbatim}

To begin, a descriptive name of the filter ({\it name "XMol XYZ"}), the common filename extension of the format ({\it extension xyz}), and a shell-style glob for the GUI file dialogs ({\it glob *.xyz}) are provided, giving the filetype description of the format. One post-load request is made, {\it rebond}, which indicates that bonds should be calculated for the model once all atoms have been loaded. Following this the list of commands to run when importing the file is given, beginning with the keyword {\it import}, and terminated with a matching {\it end} command. Recalling the structure of the xyz format, we expect to find the number of atoms on the first line, followed by the title of the model on the next, and then the atom data one per line after that. So, step-by-step the actions of the commands in this section are as follows:


\begin{description}
	\item[\texttt{readline "\$natoms"}\its]
		The {\it readline} command reads a line from the file and parses it according to some {\it format string}. Many commands rely on the use of format strings to interpret and store data. For now, we just appreciate that in this case the first item found on the line read from the file is placed in a variable named \qte{natoms}, which can then be used elsewhere.
	\item[\texttt{readline "\$title@100"}\its]
		Similar to the first command -- here we take the first 100 characters from the line and store it in a variable named \qte{title} -- here, \qte{title} is a variable name recognised internally by the program, and will be used to set the name of the model after import has finished.
	\item[\texttt{repeat \$n \$natoms}\its]
		The repeat loop runs a section of commands for a specified number of iterations (storing the value of the current iteration in a variable called \qte{n}). In this case the number of iterations is determined by the value of the variable {\it natoms} to allow us to read in the expected number of atomic data.
	\item[\texttt{readline "\$e \$r.x \$r.y \$r.z \$q"}\its]
		Here, the format string given to the readline command contains five parameters in line with the expected ordering of data in the XMol XYZ format. That is, the element symbol followed by the atomic coordinates, and then (possibly) an atomic charge.
	\item[\texttt{addatom}\its]
		At this point the current values of the temporary atom variables in the filter (in this example only the element, atomic coordinates, and atomic charge have been set) are saved in a new atom created in the model space.
	\item[\texttt{end}\its]
		Signals the end of the repeat loop.
	\item[\texttt{rebond}\its]
		Automatically calculate bonds between the atoms of the model.
\end{description}

XXX

\section{Filter Commands}
\label{sec:filtercmds}
\index{filter commands}

\subsection{File Description}
Definitions of the target file type and how to recognise it. Should be supplied in each filter section defined in a file.\\
\begin{description}

	\item[extension $list$\its]
	\index{filter commands!extension}
	Sets the filename extension that identifies files to be read / written by this filter.
	\begin{itemize}
		\item $e.g.$ \ttqte{extension xyz} means that files with extension \qte{xyz} will be recognised by this filter.
		\item $e.g.$ \ttqte{extension \dqte{xyz,abc,foo}} means that files with extensions \qte{xyz}, \qte{abc}, and \qte{foo} will be recognised by this filter.
	\end{itemize}

	\item[exact $list$\its]
	\index{filter commands!exact}
	Defines one or more exact filenames that identify files to be read / written by this filter.
	\begin{itemize}
		\item $e.g.$ \ttqte{exact coords} associates any file called \qte{coords} to this filter.
		\item $e.g.$ \ttqte{exact \dqte{results,output}} associates any files called \qte{results} or \qte{output} to this filter.
	\end{itemize}

	\item[filter $glob$\its]
	\index{filter commands!filter}
	Sets the file dialog filter extension to use in the GUI to the shell-style glob $glob$.
	\begin{itemize}
		\item $e.g.$ \ttqte{glob *.doc} filters any file matching \qte{*.doc} in the relevant GUI file selector dialogs.
	\end{itemize}

	\item[name $name$\its]
	\index{filter commands!name}
	Sets the long name of the filter to $name$, to be used as the filetype description of files identified by the filter.
	\begin{itemize}
		\item $e.g.$ \ttqte{name \dqte{SuperHartree Coordinates File}}.
	\end{itemize}

	\item[nickname $nick$\its]
	\index{filter commands!nickname}
	Sets the nickname of the filter to $nick$, which allows the filter to be identified in scripts.
	\begin{itemize}
		\item $e.g.$ \ttqte{nickname shart} sets the nickname of the filter to \qte{shart}.
	\end{itemize}

\end{description}


\subsection{Reading / Writing Data}
Commands to parse data from files and variables. Note that the style of the formatting strings differs between read and write commands.\\
\begin{description}

	\item[readline $format$\its]
	\index{filter commands!readline}
	Reads in the next line of the file (i.e., up to the carriage-return / newline marker) and splits up the data it finds into the variables specified in the $format$. The format string contains variables with optional length specifiers, separated by delimiters (e.g. spaces, commas) which serve only to separate variables -- they do not represent actual whitespace between data items in the file.
	\begin{itemize}
		\item $e.g.$ \ttqte{readline \dqte{\$n \$m \$title}} puts the first three whitespace-delimited items found on the next line in the file into the variables $n$, $m$, and $title$.
	\end{itemize}

	\item[writeline $format$\its]
	\index{filter commands!writeline}
	Constructs a string according to the $format$ given and writes it out to the file. A newline is automatically appended to the end.
	\begin{itemize}
		\item $e.g.$ \ttqte{writeline \dqte{NATOMS = \$natoms}} outputs a new line to the file, looking like \qte{NATOMS = 20}.
	\end{itemize}

	\item[print $format$\its]
	\index{filter commands!print}
	Print a message to the screen, optionally containing variables. Here, whitespace has its usual meaning since it is a simple text string. Variables to print out are written in the standard way, beginning with \qte{\$} and optionally having a length specifier. Individual variables are assumed to be terminated by either whitespace or the end of the line. If the output of characters directly after the variable is required (or variables sitting side-by-side are necessary), the variable name may be enclosed in curly brackets (e.g. \$\{$name$[@$format$]\}). A newline is automatically appended to the end.
	\begin{itemize}
		\item $e.g.$ \ttqte{print \dqte{Number of atoms = \$natoms}} writes a line to the screen looking like \dqte{Number of atoms = 11}, assuming that the variable $natoms$ has a value 11.
		\item $e.g.$ \ttqte{print \dqte{Atoms (\$\{natoms\}), bonds (\$\{nbonds\})}} writes a line to the screen looking like \dqte{Atoms (11), bonds (8)}, assuming that the variables $natoms$ and $bonds$ have values of 11 and 8 respectively.
	\end{itemize}

\end{description}


\subsection{Storing Atom Data}
Create and set data for atoms in the model, and create bonds between them.\\
\begin{description}

	\item[addatom\its]
	\index{filter commands!addatom}
	The standard way of creating a new atom in the model. The command requires no arguments, and looks for variables set in the filter to store in the atom.
	\begin{itemize}
		\item $e.g.$ \ttqte{addatom}
	\end{itemize}

	Variables recognised by the command are:
	\begin{description}
		\item[$e$\its]
			Element symbol/Z/fftype of the atom
		\item[$r.x$, $r.y$, $r.z$\its]
			Coordinates of the atom.
		\item[$f.x$, $f.y$, $f.z$\its]
			Forces of the atom.
		\item[$v.x$, $v.y$, $v.z$\its]
			Velocities of the atom.
		\item[$q$\its]
			Charge on the atom
		\item[$id$\its]
			Numeric ID of the atom, used for bonding (see later).
	\end{description}
	If any of the variables cannot be found then the relevant properties are not set, otherwise the variables are reset afterwards ready for the next atom. Should the element variable $e$ be blank then the atom is set to element 0 (\qte{XX}). The numeric ID of the atom given by $id$ is a special case. If set it is stored as the atom's internal ID and can be referenced by the \qte{addbond} command, but as soon as loading has been finalised the atomic IDs are renumbered internally -- atom IDs set from the $id$ variable will not persist into the code.

	\item[addbond $id1$ $id2$ [$type$]\its]
	\index{filter commands!addbond}
	Bond two atoms with the specified IDs together with a singlne bond (if no bond type is specified) or of the type specified in $type$. The bond type may be given as a bond order (e.g. single = 1, double = 2, triple = 3) or as a string (\qte{single}, \qte{double}, or \qte{triple}). If the supplied $type$ is not recognised a single bond is used instead.
	\begin{itemize}
		\item $e.g.$ \ttqte{addbond 2 3} creates a single bond between atoms 2 and 3.
		\item $e.g.$ \ttqte{addbond 10 5 $btype$} creates a bond between atoms 10 and 5 whose type is held in the variable $btype$.
		\item $e.g.$ \ttqte{addbond 5 6 2} creates a double bond between atoms 5 and 6.
	\end{itemize}

	\item[createatoms $n$\its]
	\index{filter commands!createatoms}
	Creates a number $n$ of atoms at once in the model, whose properties may then be set individually (in any order) with the \qte{setatom} command. Atoms are all created initially with coordinates, forces, and velocities set to (0.0,0.0,0.0), a charge of 0.0, and with element type 0.
	\begin{itemize}
		\item $e.g.$ \ttqte{createatoms 52} creates 52 new atoms in the model.
		\item $e.g.$ \ttqte{createatoms $natoms$} creates new atoms in the model, the number depending on the value of the variable $natoms$.
	\end{itemize}

	\item[modeltemplate\its]
	\index{filter commands!modeltemplate}
	For use when reading trajectory frames, this command creates $n$ new atoms in the frame (where $n$ is the number of atoms currently in the parent model of the trajectory) and copies the element, colour, and rendering style data from the atoms in the parent model. Other properties such as the coordinates, velocities, and forces can then be defined with one of the \qte{set*} commands.
	\begin{itemize}
		\item $e.g.$ \ttqte{modeltemplate}.
	\end{itemize}

	\item[setatom $id$\its]
	\index{filter commands!setatom}
	Set the properties of the atom with the specified ID from variables set in the filter. The variables searched for are the same as for \qte{addatom}.
	\begin{itemize}
		\item $e.g.$ \ttqte{setatom 9} sets the data for atom ID 9 based on the values of variables already set in the filter.
		\item $e.g.$ \ttqte{setatom $i$} sets the data for atom $i$ based on the values of variables already set in the filter.
	\end{itemize}

	\item[setrx $id$ $value$\its]
	\index{filter commands!setrx}
	\item[setry $id$ $value$\its]
	\index{filter commands!setry}
	\item[setrz $id$ $value$\its]
	\index{filter commands!setrz}
	\item[setfx $id$ $value$\its]
	\index{filter commands!setfx}
	\item[setfy $id$ $value$\its]
	\index{filter commands!setfy}
	\item[setfz $id$ $value$\its]
	\index{filter commands!setfz}
	\item[setvx $id$ $value$\its]
	\index{filter commands!setvx}
	\item[setvy $id$ $value$\its]
	\index{filter commands!setvy}
	\item[setvz $id$ $value$\its]
	\index{filter commands!setvz}
	Set individual properties of the specified atom referenced by its ID. 
	\begin{itemize}
		\item $e.g.$ \ttqte{setrx 8 $posx$} sets the x-coordinate of atom 8 to the value of $posx$.
		\item $e.g.$ \ttqte{setfz 1 0.0} sets the z-component of the atomic forces of atom 1 to zero.
	\end{itemize}

\end{description}


\subsection{Loops}
Commands to perform plain repeat loops and loops over patterns, molecules, atoms, and forcefield terms. For loops that run over aspects of the model (e.g. atoms) the counter variable, elements of the control variable (e.g. the atom's name, coordinates etc.) may be accessed by referencing in the form $variable$.$property$. For example, the name and element symbol of an atom variable named \qte{i} may be retrieved with \qte{i.name} and \qte{i.symbol} respectively. Full lists of the variables set by the loops are given in the folowing list. All loop blocks must be terminated with an \qte{end} command.
\begin{description}

	\item[foratoms $var$ [$pattern$ [$molecule$]]\its]
	\index{filter commands!foratoms}
		Loop that runs over atoms in a model, pattern, or pattern molecule. The required variable $var$ is used to reference the current atom, while the second (optional) variable determines a specific pattern over which to loop (which may further be given a molecule number over which to restrict to). If only thne control variable is supplied the loop runs over all atoms in the current model.

		\begin{itemize}
			\item $e.g.$ to loop over all atoms $i$ in the model
			\begin{verbatim}
				foratoms $i
				...
				end
			\end{verbatim}

			\item $e.g.$ to loop over each atom $i$ in the representative molecule of a pattern referenced by $patternvar$
			\begin{verbatim}
				foratoms $atomnum $patternvar
				...
				end
			\end{verbatim}

			\item $e.g.$ to loop over all atoms $i$ in a specific molecule $m$ of pattern $p$
			\begin{verbatim}
				foratoms $i $p $m
				...
				end
			\end{verbatim}

			\item Properties available for the atom control variable are:
			\begin{description}
				\item[$symbol$\its]
					Element symbol of the atom.
				\item[$z$\its]
					Atomic number $Z$ of the atom.
				\item[$mass$\its]
					Atomic mass of the atom.
				\item[$name$\its]
					Element name of the atom.
				\item[$r.x$, $r.y$, $r.z$\its]
					Coordinates of the atom.
				\item[$f.x$, $f.y$, $f.z$\its]
					Forces of the atom.
				\item[$v.x$, $v.y$, $v.z$\its]
					Velocities of the atom.
				\item[$q$\its]
					Charge on the atom.
				\item[$fftype$\its]
					Forcefield type name associated to the atom (or \qte{???} if none).
				\item[$ffequiv$\its]
					Forcefield equivalent type name associated to the atom (or \qte{???} if none).
			\end{description}
		\end{itemize}

	\item[forffbonds $var$ $pattern$]
	\item[forffangles $var$ $pattern$]
	\item[forfftorsions $var$ $pattern$\its]
	\index{filter commands!forffbonds}
	\index{filter commands!forffangles}
	\index{filter commands!forfftorsions}
		Loops that run over the different forcefield elements of a pattern.
		\begin{itemize}
			\item $e.g.$ to loop over all patterns $p$ in the model
			\begin{verbatim}
				forpatterns $p
				...
				end
			\end{verbatim}

			Properties available for the control variable are:
			\begin{description}
				\item[$funcform$\its]
					Functional form of the term, corresponding to the keyword names in the original forcefield file (see Section XXX).
				\item[$id$\_$i$]
				\item[$id$\_$j$]
				\item[...\its]
					Molecule-relative ids of the atoms $i$, $j$, etc. involved in the term.
				\item[$param$\_$a$]
				\item[$param$\_$b$]
				\item[...\its]
					Parameters of the interaction, corresponding to the input order in the forcefield file (see Section XXX).
				\item[$type$\_$i$]
				\item[$type$\_$j$]
				\item[...\its]
					Forcefield types of the atoms $i$, $j$, etc. involved in the term.
			\end{description}
		\end{itemize}

	\item[formolecules $var$ $pattern$\its]
	\index{filter commands!formolecules}
		Specialised loop that runs over molecules in the patterns of a model, and so is of use when exporting data. The variable $var$ is used to store the current molecule number.
		\begin{itemize}
			\item $e.g.$ to loop over all molecules $m$ in a pattern $thispat$
			\begin{verbatim}
				formolecules $m $thispat
				...
				end
			\end{verbatim}
		\end{itemize}

	\item[forpatterns $var$\its]
	\index{filter commands!forpatterns}
		Specialised loop that runs over the patterns of a model, and so is of use when exporting data.
		\begin{itemize}
			\item $e.g.$ to loop over all patterns $p$ in the model
			\begin{verbatim}
				forpatterns $p
				...
				end
			\end{verbatim}

			Properties available for the pattern control variable are:
			\begin{description}
				\item[$name$\its]
					Name of the pattern.
				\item[$nmols$\its]
					Number of molecules encompassed by the pattern.
				\item[$nmolatoms$\its]
					Number of atoms per molecule.
				\item[$name$\its]
					Element name of the atom.
				\item[$nbonds$\its]
					Number of forcefield bond terms used in the expression for the pattern.
				\item[$nangles$\its]
					Number of forcefield angle terms used in the expression for the pattern.
				\item[$ntorsions$\its]
					Number of forcefield torsion terms used in the expression for the pattern.
			\end{description}
		\end{itemize}


	\item[repeat $var$ [$niter$]\its]
	\index{filter commands!repeat}
	Repeat commands up to the next \qte{end} for a number of iterations, storing loop iteration number in the variable $var$. $niter$ may either be a previously-initialised variable containing the number of iterations to perform, or an integer value. If $niter$ is not supplied the loop runs indefinitely and can only be terminated by the \qte{XXX} command or by reaching the end of the file.
	\begin{itemize}
		\item $e.g.$ \ttqte{repeat \$n} loops indefinitely, storing the current loop iteration in $n$.
		\item $e.g.$ \ttqte{repeat \$natoms 164} loops 164 times storing the current loop iteration in a variable $natoms$.
		\item $e.g.$ \ttqte{repeat \$atomno \$size} loops for the integer value of the $size$ variable, storing the current loop iteration in a variable $atomno$.
	\end{itemize}

	\item[while $var$ $test$ $value$\its]
	\index{filter commands!while}
	Repeats the commands in the following block while the condition provided evaluates to true (tested at the start of the block).
	\begin{itemize}
		\item $e.g.$ \ttqte{while element = Cl} loops while the variable $element$ contains a value of \qte{Cl}.
	\end{itemize}

\end{description}

\subsection{Storing a Unit Cell}
In particular, methods to set a handful of related variables for use in the filter, and to create / describe atoms from sets of known variables.\\
\begin{description}

	\item[setcell\its]
	\index{filter commands!setcell}
	Set the unit cell for the model / trajectory frame from cell length and angle variables already set in the filter. Lengths should be given in Angstroms and angles in degrees. The command expects to find values in:
	\begin{description}
		\item[$cell.a$]
		\item[$cell.b$]
		\item[$cell.c$\its]
			Lengths of the three cell axes.
		\item[$cell.alpha$]
		\item[$cell.beta$]
		\item[$cell.gamma$\its]
			Angles between cell axes.
	\end{description}

	\item[setcellaxes\its]
	\index{filter commands!setcellaxes}
	Set the unit cell for the model / trajectory frame from an axis matrix definition already set in the filter. Unit of length for axis definitions is \AA{}ngstroms. The command expects to find values in:
	\begin{description}
		\item[$cell.a.x$]
		\item[$cell.a.y$]
		\item[$cell.a.z$\its]
			Vector components of the cell's $A$ vector.
		\item[$cell.b.x$]
		\item[$cell.b.y$]
		\item[$cell.b.z$\its]
			Vector components of the cell's $B$ vector.
		\item[$cell.c.x$]
		\item[$cell.c.y$]
		\item[$cell.c.z$\its]
			Vector components of the cell's $C$ vector.
	\end{description}

	\item[setspacegroup $spgrp$\its]
	\index{filter commands!setspacegroup}
	Set the spacegroup for a periodic model, allowing symmetry copies of atoms to be generated with the \qte{pack} command.

\end{description}


\subsection{Testing Conditions}
Ways to perform tests on variables within the filter.\\
\begin{description}

	\item[if $var$ $test$ $value$\its]
	\index{filter commands!if}
	Tests the contents of the variable $var$ against either another variable named $value$, or a literal string $value$ (which it is assumed to be if a variable named $value$ does not currently exist) and executes the commands in the following block if the test is true. See Section \ref{sec:variables} for a list of tests and the way they are performed.
	\begin{itemize}
		\item $e.g.$ \ttqte{if \$natoms = 30} checks if the variable $natoms$ equals \qte{30}.
		\item $e.g.$ \ttqte{if \$style <> formatted} checks if the variable $style$ equals the string \qte{formatted}.
	\end{itemize}

	\item[else\its]
	\index{filter commands!else}
	Closes the command block of the most recent (as yet unterminated) \qte{if} or \qte{elseif} and begins another block, the contents of which will be executed if none of the preceeding tests evaluate to true.
	\begin{itemize}
		\item $e.g.$ \ttqte{else}
	\end{itemize}

	\item[elseif $var$ $test$ $value$\its]
	\index{filter commands!elseif}
	Closes the command block of the most recent (as yet unterminated) \qte{if} or \qte{elseif} and begins another \qte{if} block, the contents of which will be executed if its condition evaluates to true.
	\begin{itemize}
		\item $e.g.$ \ttqte{elseif \$natoms = 50} checks if the variable $natoms$ equals \qte{50}, executing the commands within the following block if this is so.
	\end{itemize}
	
	\item
		\begin{itemize}
			\item[$e.g.$]
			\begin{verbatim}
				if $name = alan
				  ...do something...
				elseif $name = bill
				  ...do something else...
				elseif $job = done
				  ...test on different variable...
				else
				  ...contingency plan...
				end
			\end{verbatim}
		\end{itemize}

\end{description}




By default, the atomic numbers of imported atoms are decoded from element symbols since this is the most common way in which they are represented in molecule file formats. Case is unimportant, so \qte{na}, \qte{Na}, and \qte{NA} will all be interpreted as atomic number 11 (sodium). When this proves to be inadequate, several extra options are available (set through the command line or file import dialog) allowing atomic numbers to be determined in different ways. The \qte{ff} option is particularly useful when loading in coordinate files which have atom names which do not necessarily correspond trivially to element information (e.g. DL\_POLY configurations) and where the atomic numbers of atoms cannot uniquely be determined from a simple comparison with element symbols. When decoding forcefield types, all forcefields which have been imported prior to model loading will be searched for the type names in the model file, and the atomic number set accordingly to the first exact match found.



\index{filters|)}
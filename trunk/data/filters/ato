# Coordinate (ATO) file for Empirical Potential Structure Refinement (EPSR) software ( (C) Rutherford Appleton Labs )
# Created:	 23/03/2011
# Last modified: 02/09/2011
# ChangeLog:
#	02/09/2011 - Tweaked to use capitalised command/member names in v1.8
# 	28/05/2011 - Added writing of random numbers on export. Fixed import to recognise end of LJ specifications.
# 	23/03/2011 - Initial version.

filter(type="importmodel",name="EPSR ATO File", nickname="ato", extension="ato", glob="*.ato", id=18)
{
	// Variables
	atom i;
	int nmols,m,n,l,natoms,nres,nrot,count,done,id,nrotatoms;
	element el;
	double boxsize, temp, eps, sigma, mass, q;
	string atomname, elname, line, dummy;
	vector com, r, phi;
	ffatom ffa;

	addReadOption("skipblanks");

	// File header:
	// Either  1   : nmols, box length, temperature   (for cubic systems)
	//    or   2   : nmols,   temperature             (for non-cubic systems)
	// followed by : A, B, C
	//             : phib, thetac, phic
	if (!readLine(nmols, boxsize, dummy)) error("Failed to read header information from file.\n");
	newModel("ATO file");
	if (dummy == "")
	{
		printf("File contains specific unit cell information.\n");
		double a, b, c, phib, thetac, phic;
		if (!readLine(a, b, c)) error("Failed to read unit cell lengths from file.\n");
		if (!readLine(phib, thetac, phic)) error("Failed to read unit cell lengths from file.\n");
		// phib = angle between a and b (== gamma)
		// thetac = angle deviation from cartesian z (== 90-beta)  ?? CHECK
		// phic = angle deviation from cartesian z (== 90-alpha)  ?? CHECK
		cell(a, b, c, 90-phic, 90-thetac, phib);
	}
	else cell(boxsize,boxsize,boxsize,90,90,90);

	// 2 : step sizes etc. (ignore)
	skipLine();

	// Molecule/atom specifications are in the form:
	// n  : natoms, comx, comy, comz, phix, phiy, phiz
	// n+1: atom name 1
	// n+2: x,y,z (offsets from com)
	// n+3: nrestraints, res1, res2... (number of distance restraints, 5 per line)
	// n+4: ...resN-1, resN
	// n+5: nrot (number of defined molecular rotations)
	// n+6: atom1, atom2 (bonds of rotation 'axis')
	// n+7: list of headgroup atoms that are rotated
	count = 0;
	for (m=0; m<nmols; m++)
	{
		if (!readLine(natoms, com.x, com.y, com.z, phi.x, phi.y, phi.z)) error("Error reading information for molecule %i.\n", m+1);

		for (n=0; n<natoms; n++)
		{
			// Basic atom information
			if (!readLine(atomname)) error("Error reading atom name %i for molecule %i\n", n+1, m+1);
			if (!readLine(r.x, r.y, r.z)) error("Error reading atom coordinates %i for molecule %i\n", n+1, m+1);
			// Adjust for molecule centre of mass, and also apply a half-cell translation since EPSR uses -0.5 -> 0.5 coordinates
			r += com;
			r += aten.model.cell.centre;
			// Create a new atom with element 0 - it will be set to a proper element later on
			i = newAtom(0, r.x, r.y, r.z);
			i.data = atomname;

			// Apply restraint information as bonds
			if (!nextArg(nres)) error("Error reading nrestraints for atom %i of molecule %i.\n", n+1, m+1);
			for (l=0; l<nres; ++l)
			{
				if (!nextArg(id) || !nextArg(temp)) error("Erro reading restraint information %i for atom %i of molecule %i.\n", l+1, n+1, m+1);
				// If the relative atom id is greater than the current atom number, ignore it (it will be repeated the other way around for the second atom)
				if (id > (n+1)) continue;
				newBond(count+n+1, count+id);
			}
		}

		// Discard molecular rotations
		// There are 14 atoms per line - first line contains number of atoms followed by (up to) 13 indices
		if (!readLine(nrot)) error("Error reading nrotations for atom %i of molecule %i.\n", n+1, m+1);
		for (n=0; n<nrot; ++n)
		{
			// Skip ROT and axis lines
			skipLine(2);
			// Read in number of atoms and find next number of lines to discard
			readLine(nrotatoms);
			skipLine(nrotatoms/14);
		}

		count += natoms;
	}

	// Atomtype specifications follow
	// Read in until we find don't find an element symbol (i.e. a number).  
	done = FALSE;
	Forcefield ff = newFF("Atomtypes from ATO file");
	count = 0;
	do
	{
		++count;
		// Two lines per atomtype
		//   name, symbol, 0/isomass
		//   epsilon  sigma  mass  charge
		if (!readLine(atomname, elname, dummy)) error("Error reading atomtype information %i.\n", count);
		// If 'dummy' is empty, chances are we've gone on to the fmole numbers (which has no third data)
		if (dummy == "") break;
		if (!readLine(eps, sigma, mass, q)) error("Error reading atomtype LJ information %i.\n", count);
		el = aten.findElement(elname);
		if (el == 0) 
		{
			printf("Failed to map element name '%s' to an element.  Attempting to use atomname (%s) instead...\n", elname, atomname);
			el = aten.findElement(atomname);
		}
		if (el != 0) printf("       : Mapping atom name %s to %s.\n", atomname, el.symbol);
		else printf("       : Mapping atom name %s to XXX (unknown).\n", atomname);
		ffa = ff.addType(count, atomname, atomname, el, "", "");
		for (i in aten.model.atoms) if (i.data == atomname) { i.element = el; i.type = ffa; }
		ff.addInter("lj", count, q, eps, sigma);
	} while (!done);
	ff.finalise();

	finaliseModel();
}

filter(type="exportmodel",name="EPSR ATO File", nickname="ato", extension="ato", glob="*.ato", id=18)
{
	# Variable declaration
	model srcmodel= aten.frame;
	pattern p;
	int nmols, n, m, o, mol, nresb, nresa, nrest, nrot, idj, count;
	double rij, mass, boxsize;
	vector com, r;
	atom i, j;
	bound b;
	bond bnd;

	# Main dialog creation function
	void createDefaultDialog(Dialog ui)
	{
		Widget w, group;
		ui.title = "ATO File Export Options";
		ui.verticalFill = TRUE;

		ui.addDoubleSpin("temperature", "Temperature", 0.0, 100000.0, 10.0, 300.0);
		ui.addDoubleSpin("epsr_tol", "Tolerance", 0.0, 1.0, 0.1, 0.0);

		# Step Sizes
		group = ui.addGroup("stepsizes", "Step Sizes", -1, -1, 1);
		group.verticalFill = TRUE;
		group.addDoubleSpin("epsr_itrans", "Intramolecular Translations", 0.0, 100.0, 1.0, 1.5);
		group.addDoubleSpin("epsr_hrot", "Headgroup Rotations", 0.0, 10.0, 0.1, 2.5);
		group.addDoubleSpin("epsr_mrot", "Whole Molecule Rotations", 0.0, 10.0, 0.1, 1.0);
		group.addDoubleSpin("epsr_mtrans", "Whole Molecule Translations", 0.0, 10.0, 0.01, 0.1);
		ui.addDoubleSpin("epsr_vtemp", "Vibrational Temperature", 0.0, 1500.0, 10.0, 65.0);

		# Restraints
		group = ui.addGroup("restraints", "Restraints", -1, -1, 1);
		ui.addRadioGroup("restraintgroup");
		group.addRadioButton("restrain_con", "Restrain Based on Connectivity", "restraintgroup", 1);
		group.addRadioButton("restrain_dist", "Restrain Based on Distance", "restraintgroup", 0);
		# -- by Connectivity
		w = group.addFrame("restrain_con_frame", 1, 2);
		ui.addRadioGroup("connectivitygroup");
		w.verticalFill = TRUE;
		w.addRadioButton("restrain_bonds", "Across Bonds", "connectivitygroup", 1);
		w.addRadioButton("restrain_angles", "Across Angles","connectivitygroup",  0);
		w.addRadioButton("restrain_torsions", "Across Torsions", "connectivitygroup", 0);
		w.addDoubleSpin("restrain_con_max", "Maximum Distance", 0.0, 10.0, 0.1, 2.4);

		w = group.addFrame("restrain_dist_frame", 2, 2);
		w.enabled = FALSE;
		w.addDoubleSpin("restrain_dist_max", "Maximum Distance", 0.0, 10.0, 0.1, 2.4);

		ui.widget("restrain_dist").onInteger(0, 1, "sendbool", "restrain_dist_frame", "enabled");
		ui.widget("restrain_con").onInteger(0, 1, "sendbool", "restrain_con_frame", "enabled");
		ui.widget("restrain_dist").onInteger(0, 1, "sendbool", "restrain_con_frame", "disabled");
		ui.widget("restrain_con").onInteger(0, 1, "sendbool", "restrain_dist_frame", "disabled");
	}
	if (!showDefaultDialog()) error("Canceled through dialog.\n");
	Dialog ui = defaultDialog();

	// First, some checks. We need valid patterns and a cubic cell.
	if (!createExpression(FALSE,TRUE)) error("Error: Can't write ATO file without valid forcefield types assigned to all atoms.\n");

	// Line 1 : nmols, box dimension, temperature
	// First determine total number of molecules
	nmols = 0;      
	for (p in srcmodel.patterns) nmols += p.nMols;
	if (srcmodel.cell.type == "none")
	{
		// Set boxsize here to be zero (it is used elsewhere to shift by half-cell amounts, so this will prevent it)
		boxsize = 0.0;
		// Determine maximum extent of system
		printf("Model has no cell definition - determining molecular extent...\n");
		double maxrij = 0.0;
		for (atom i = srcmodel.atoms; i; ++i)
		{
			for (atom j = ++i; j; ++j)
			{
				rij = geometry(i,j);
				if (rij > maxrij) maxrij = rij;
			}
		}
		writeLineF("  %4i %13.6e  %13.6e\n", nmols, maxrij*2.0, ui.asDouble("temperature"));
	}
	else if (srcmodel.cell.type == "cubic")
	{
		boxsize = srcmodel.cell.a;
		writeLineF("  %4i %13.6e  %13.6e\n",nmols,srcmodel.cell.a, ui.asDouble("temperature"));
	}
	else
	{
		writeLineF("  %4i %13.6e\n", nmols, ui.asDouble("temperature"));
		writeLineF(" %12.6e  %12.6e  %12.6e\n", srcmodel.cell.a, srcmodel.cell.b, srcmodel.cell.c);
		// Angles must be determined:
		// thetac = angle deviation from cartesian z (== 90-beta)  ?? CHECK
		// phic = angle deviation from cartesian z (== 90-alpha)  ?? CHECK
		writeLineF(" %12.6e  %12.6e  %12.6e\n", srcmodel.cell.gamma, 90.0-srcmodel.cell.beta, 90.0-srcmodel.cell.alpha);
	}

	// Line 2 : Tol, step sizes (intra trans, headgroup rot, mol rot, mol trans), vibrational temp
	writeLineF("  %10.3e  %10.3e  %10.3e  %10.3e  %10.3e  %10.3e\n", ui.asDouble("epsr_tol"), ui.asDouble("epsr_itrans"), ui.asDouble("epsr_hrot"), ui.asDouble("epsr_mrot"), ui.asDouble("epsr_mtrans"), ui.asDouble("epsr_vtemp"));

	// Atom/molecule loop
	mol = 0;
	i = srcmodel.atoms;
	for (p in srcmodel.patterns)
	{
		for (m=1; m<=p.nMols; ++m)
		{
			++mol;
			// Write centre of mass
			com = p.com(m) - boxsize*0.5;
			writeLineF("   %-2i %13.6e %13.6e %13.6e %13.6e %13.6e %13.6e %5i\n",p.nMolAtoms,com.x,com.y,com.z,0.0,0.0,0.0,mol);

			// Write atom information
			for (n=1; n<=p.nMolAtoms; ++n)
			{
				if (i.type == 0) writeLineF(" %-3s     %5i\n", i.symbol, n);
				else writeLineF(" %-3s     %5i\n", i.type.name, n);

				// Get mim vector to COM
				r = srcmodel.cell.mimVector(com, i.r - boxsize*0.5);
				writeLineF(" %12.5e %12.5e %12.5e\n", r.x, r.y, r.z);

				// Restraint information
				count = 0;
				if (ui.asInteger("restrain_con"))
				{
					nresb = 0;
					nresa = 0;
					nrest = 0;
					double rijmax = ui.asDouble("restrain_con_max");
					if (ui.asInteger("restrain_bonds")) for (b in p.bonds) if (((b.id[1] == n) || (b.id[2] == n)) && (geometry(p.atoms[b.id[1]],p.atoms[b.id[2]]) < rijmax)) ++nresb;
					if (ui.asInteger("restrain_angles")) for (b in p.angles) if (((b.id[1] == n) || (b.id[3] == n)) && (geometry(p.atoms[b.id[1]],p.atoms[b.id[3]]) < rijmax)) ++nresa;
					if (ui.asInteger("restrain_torsions")) for (b in p.torsions) if (((b.id[1] == n) || (b.id[4] == n)) && (geometry(p.atoms[b.id[1]],p.atoms[b.id[4]]) < rijmax)) ++nrest;
					writeLineF("  %2i", nresa+nresb+nrest);
					if (nresb > 0) for (b in p.bonds)
					{
						// Search for bonds in which this atom is involved
						if (b.id[1] == n) idj = b.id[2];
						else if (b.id[2] == n) idj = b.id[1];
						else continue;
						rij = geometry(p.atoms[b.id[1]],p.atoms[b.id[2]]);
						if (rij > rijmax) continue;
						if (count && (count%5 == 0)) writeLineF("\n");
						++count;
						writeLineF("%4i %9.3e ", idj, rij);
					}
					if (nresa > 0) for (b in p.angles)
					{
						// Search for angles in which this atom is involved
						if (b.id[1] == n) idj = b.id[3];
						else if (b.id[3] == n) idj = b.id[1];
						else continue;
						rij = geometry(p.atoms[b.id[1]],p.atoms[b.id[3]]);
						if (rij > rijmax) continue;
						if (count && (count%5 == 0)) writeLineF("\n");
						++count;
						writeLineF("%4i %9.3e ", idj, rij);
					}
					if (nrest > 0) for (b in p.torsions)
					{
						// Search for torsions in which this atom is involved
						if (b.id[1] == n) idj = b.id[4];
						else if (b.id[4] == n) idj = b.id[1];
						else continue;
						rij = geometry(p.atoms[b.id[1]],p.atoms[b.id[4]]);
						if (rij > rijmax) continue;
						if (count && (count%5 == 0)) writeLineF("\n");
						++count;
						writeLineF("%4i %9.3e ", idj, rij);
					}
					writeLineF("\n");
				}
				else
				{
					nresb = 0;
					double rijmax = ui.asDouble("restrain_dist_max");
					for (idj = 1; idj<=p.nMolAtoms; ++idj) if ((n != idj) && (geometry(p.atoms[n],p.atoms[idj]) < rijmax)) ++nresb;
					writeLineF(" %4i", nresb);
					if (nresb > 0) for (idj = 1; idj<=p.nMolAtoms; ++idj)
					{
						if (n == idj) continue;
						rij = geometry(p.atoms[n],p.atoms[idj]);
						if (rij < rijmax) writeLineF("%4i %9.3e ", idj, rij);
					}
					writeLineF("\n");
				}

				++i;
			}

			// Write headgroup rotations
			nrot = 0;
			for (b in p.bonds)
			{
				if (p.atomsInRing(b.id[1],b.id[2])) continue;
				if (p.atoms[b.id[1]].nBonds == 1) continue;
				if (p.atoms[b.id[2]].nBonds == 1) continue;
				++nrot;
			}
			writeLineF(" %5i\n", nrot);
			if (nrot > 0)
			{
				for (b in p.bonds)
				{
					if (p.atomsInRing(b.id[1],b.id[2])) continue;
					if (p.atoms[b.id[1]].nBonds == 1) continue;
					if (p.atoms[b.id[2]].nBonds == 1) continue;
					bnd = p.atoms[b.id[1]].findBond(p.atoms[b.id[2]]);
					writeLine(" ROT");
					writeLineF("%5i%5i\n", b.id[1], b.id[2]);
					srcmodel.selectNone();
					srcmodel.selectTree(p.atoms[b.id[1]], bnd);
					// Check here the number of selected atoms - if greater than half the atoms in the molecule then we're better off with the inverse selection!
					if (srcmodel.nSelected > 0.5*p.nMolAtoms)
					{
						for (o=1; o<=p.nMolAtoms; ++o)
						{
							if (p.atoms[o].selected) p.atoms[o].selected = FALSE;
							else p.atoms[o].selected = TRUE;
						}
					}
					srcmodel.deselect(p.atoms[b.id[1]], p.atoms[b.id[2]]);
					// List of rotating atoms should be given 14 per line (13 + natoms on the first line)
					count = 1;
					writeLineF(" %4i", srcmodel.nSelected);
					for (j in srcmodel.selection)
					{
						if (count%14 == 0) writeLineF("\n");
						writeLineF(" %4i", j.id-p.firstAtomId+1);
						++count;
					}
					writeLineF("\n");
				}
			}
		}
	}

	// Write the forcefield info
        // Energy unit must be kj/mol, so set automatic conversion of ff energy parameters to kj
        autoConversionUnit("kj");
	for (ffatom ffa in srcmodel.ffTypes)
	{
		if ((ffa.form != "lj") && (ffa.form != "ljgeom")) error("Error: Atom type '%s' contains short-range parameters of an incompatible type with EPSR (%s).\n", ffa.name, ffa.form);
		if (ffa.z == 1) writeLineF(" %3s %3s    %1i\n", ffa.name, aten.elements[ffa.z].symbol, 1);
		else writeLineF(" %3s %3s    %1i\n", ffa.name, aten.elements[ffa.z].symbol, 0);

		// Masses - for H atoms, write deuterium mass instead
		if (ffa.z == 1) mass = 2.0;
		else mass = aten.elements[ffa.z].mass;
		writeLineF(" %10.4e  %10.4e  %10.4e  %10.4e  %10.4e\n", ffa.parameter("epsilon"), ffa.parameter("sigma"), mass, ffa.charge, 0.0);
	}
	
	// Extra data

	// Used by fmole to keep non-bonded atoms apart
	writeLineF(" %10.4e  %10.4e\n", 1.0, 3.0);

	// Random numbers for restart purposes
	for (n=0; n<15; ++n) writeLineF(" %i", randomI());
	writeLineF("\n");
	
}


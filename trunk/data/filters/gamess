# GAMESS-US Output Filter, and Cartesian Input Model Filters (I/O) (for v1.2+)
# Created:	 14/04/2009
# Last modified: 29/10/2010
# ChangeLog:
#	29/10/2010 - Major update to log file filter - ability to read in basis set, MOs, and vibrations added
#	14/09/2010 - Tweaks to options output in GUI filter. Standard DFTTYPs added.
#	25/08/2010 - Added GUI options to output filter
#	12/05/2010 - Changed id of log file filter to 11 (was 10, which conflicted with MDL Molfile in 'mol')
#	13/10/2009 - Last frame and parent frame from logfile are now deselected.
# Notes:
#	Output model filter sets symmetry to C1, regardless of the actual symmetry.

filter(type="importmodel", name="GAMESS-US Log File", nickname="gamuslog", extension="log", glob="*.log", zmap="name", search="GAMESS VERSION", id=11)
{
	# Variable declaration
	int result,nstructures,natoms,n,l,lastshell,shell,count,orb_no[5];
	basisshell bas;
	basisprimitive prim;
	eigenvector orbs[5];
	vibration vibs[5];
	string line,e,name,discard,orb_symm[5],type, vib_imag[5];
	double rx,ry,rz, exponent,coeff,orb_nrg[5], orb_coeff[5];
	double vib_freq[5], vib_dx[5], vib_dy[5], vib_dz[5], vib_rmass[5], vib_ir[5];

	# Create a new model, and store its pointer for use later
	model m = newmodel("GAMESS-US Output");

	# Find initial coordinates (in Bohr)
	if (find("ATOM      ATOMIC                      COORDINATES (BOHR)"))
	{
		skipline();
		while (readline(e,discard,rx,ry,rz) != 0)
		{
			newatom(e,rx,ry,rz);
		}
		bohr(aten.model);
		rebond();
	}
	else error("No coordinates in file?");

	# Read in basis set information
	if (find("ATOMIC BASIS SET"))
	{
		skipline(6);
		# Loop over basis shell definitions, stopping when we find the text 'TOTAL'
		readlinef("%s %s %i %f %r", e, name, n, exponent, line);
		#printf("%s %s %i %f [%s]\n", e, name, n, exponent, line);
		lastshell = -1;
		count = 0;
		while (e != "TOTAL")
		{
			# Start of a new atom?
			if (n == 0)
			{
				count ++;
				lastshell = 0;
				#printf("Found start of atom %i, which is element %s\n", count, e);
			}
			else
			{
				# Create new basis shell?
				shell = atoi(e);
				#if (lastshell != shell) printf("Lastn (%i) is != shell (%i), so creating a new shell...\n", lastshell, shell);
				if (lastshell != shell) bas = m.newbasisshell(count, name);
				lastshell = shell;
			}

			# Store primitive's exponent and coefficient(s)
			if (lastshell != 0)
			{
				prim = bas.addprimitive(exponent);
				# Cycle over provided coefficients
				while (nextvararg(line,coeff)) prim.addcoefficient(coeff);
			}

			# Get next line, ignoring blanks
			do
			{
				readlinef("%s %s %i %f %r", e, name, n, exponent, line);
			} while (e == "");
			#printf("%s %s %i %f [%s]\n", e, name, n, exponent, line);
		}
		# We end up with the 'TOTAL NUMBER OF BASIS SET SHELLS' line (beginning at 'SET...'), so we can do a check
		readvar(line, discard, discard, discard, n);
		printf("         Number of basis set shells read in : %i\n", m.nbasisshells());
		printf("            --> number specified in logfile : %i\n", n);
		if (n != m.nbasisshells()) error("Failed to read in basis set information.");
		# Also, check the total number of cartesian basis functions
		readlinef("%r", line);
		n = atoi( afterstr(line,"=") );
		printf("Number of implied cartesian basis functions : %i\n", m.nbasiscartesians());
		printf("            --> number specified in logfile : %i\n", n);
		if (n != m.nbasiscartesians()) error("Failed to read in basis set information.");
	}

	# Determine number of atoms - search for line containing 'TOTAL NUMBER OF ATOMS'
	if (!find("TOTAL NUMBER OF ATOMS",line)) error("Couldn't determine number of atoms from GAMESS-US output.");

	# Get number of atoms from line
	readvarf(line, "%48*%i",natoms);

	# Now search for sets of coordinate
	nstructures = 0;
	# Lines containing 'COORDINATES OF ALL ATOMS ARE' are the beginning of coordinate sections
	while (find("COORDINATES OF ALL ATOMS ARE"))
	{
		# Found a set of coordinates. Skip 2 lines and then read coordinates
		nstructures++;
		skipline(2);
		writevarf(name, "Frame %i", nstructures);
		m = addframe(name);
		for (n=1; n<=natoms; ++n)
		{
			readline(e,discard,rx,ry,rz);
			newatom(e,rx,ry,rz);
		}
		# Recalculate bonding
		rebond();
		finaliseframe();
	}

	# Molecular orbitals?
	if (find("MOLECULAR ORBITALS"))
	{
		skipline(2);
		# MO information is provided 5 orbs per line, in the format:
		#                     1          2          3          4
		#                   -0.5942     0.2657     0.9175     1.5319
		#                     A          A          A          A
		#    1  H  1  S   -0.290651  -0.111641  -0.783160   1.077794
		#    .  .  .  .
		#    NC .  .  .   
		# ...where NC is the number of cartesian basis functions.
		for (n=1; n<m.nbasisshells(); n +=5)
		{
			# Read in orbital numbers as a sanity check
			readline(discard);
			# End of orbital specification?
			if (atoi(discard) == 0) break;
			else if (n != atoi(discard))
			{
				printf("Failed to read in MO information at orbital number %i (read [%s] from file)\n", n, discard);
				break;
			}
			# Read in eigenvalues and symmetry type
			readline(orb_nrg[1], orb_nrg[2], orb_nrg[3], orb_nrg[4], orb_nrg[5]);
			readline(orb_symm[1], orb_symm[2], orb_symm[3], orb_symm[4], orb_symm[5]);
			# Create eigenvectors
			for (l=1; l<6; ++l)
			{
				if ((l+n-1) > m.nbasisshells()) break;
				verbose(" -- Created MO number %i with eigenvalue %f\n", l+n-1, orb_nrg[l]);
				orbs[l] = m.neweigenvector();
				orbs[l].eigenvalue = orb_nrg[l];
				orbs[l].name = orb_symm[l];
			}
			# Next lines contain coefficients...
			for (count=1; count<=m.nbasiscartesians(); ++count)
			{
				readline(discard,e,shell,type,orb_coeff[1], orb_coeff[2], orb_coeff[3], orb_coeff[4], orb_coeff[5]);
				for (l=1; l<6; ++l)
				{
					if ((l+n-1) > m.nbasisshells()) break;
					orbs[l].vector[count] = orb_coeff[l];
				}
			}
		}
	}

	# Frequencies?
	rewind();
	if (find("FREQUENCIES IN CM**-1"))
	{
		# Skip warning of non-stationary point if present...
		if (find("THIS IS NOT A STATIONARY POINT"))
		{
			skipline(3);
			printf(" *** The frequencies correspond to a non-stationary point.\n");
		}
		else skipline(2);
		# Vibration information is provided 5 vibrations per line, in the format:
		#                       1          2          3          4            5
		#    FREQUENCY:      39.84 I     19.94       19.03       15.12       11.87
		# REDUCED MASS:      2.15985     3.96061     4.04986     3.97821     5.98898
		# IR INTENSITY:      0.00121     0.00399     0.00426     0.00020     0.00070
		#  <blank line>
		#    1  HYDROGEN  X  0.05470495  0.01254668 -0.05069468  0.01778118 -0.01077563
		#    .  .  .  .
		#    3N .  .  .   
		# ...where N is the number of atoms in the model
		for (n=1; n<3*m.natoms(); n +=5)
		{
			# Read in vibration numbers as a sanity check
			readline(discard);
			if (n != atoi(discard))
			{
				printf("Failed to read in vibration information at vibration number %i (read [%s] from file)\n", n, discard);
				break;
			}
			# Read in frequencies and imaginary flags
			readlinef("%* %f%2s%f%2s%f%2s%f%2s%f%2s", vib_freq[1], vib_imag[1], vib_freq[2], vib_imag[2], vib_freq[3], vib_imag[3], vib_freq[4], vib_imag[4], vib_freq[5], vib_imag[5]);
			readline(discard, vib_rmass[1], vib_rmass[2], vib_rmass[3], vib_rmass[4], vib_rmass[5]);
			readline(discard, vib_ir[1], vib_ir[2], vib_ir[3], vib_ir[4], vib_ir[5]);
			# Create vibrations
			for (l=1; l<6; ++l)
			{
				if ((l+n-1) > 3*m.natoms()) break;
				verbose("Created vibration number %i with frequency %f\n", l+n-1, vib_freq[l]);
				vibs[l] = m.newvibration();
				vibs[l].frequency = vib_freq[l];
			}
			skipline(1);
			# Next lines contain atomic displacements
			for (count=1; count<=m.natoms(); ++count)
			{
				readline(discard,e,type,vib_dx[1], vib_dx[2], vib_dx[3], vib_dx[4], vib_dx[5]);
				readline(type,vib_dy[1], vib_dy[2], vib_dy[3], vib_dy[4], vib_dy[5]);
				readline(type,vib_dz[1], vib_dz[2], vib_dz[3], vib_dz[4], vib_dz[5]);
				for (l=1; l<6; ++l)
				{
					if ((l+n-1) > 3*m.natoms()) break;
				#	vibs[l].displacements[count] = { vib_dx[l], vib_dy[l], vib_dz[l] };
					vibs[l].displacements[count].x = vib_dx[l] ;
					vibs[l].displacements[count].y = vib_dy[l] ;
					vibs[l].displacements[count].z = vib_dz[l] ;
				}
			}
			# Skip over Sayvetz information
			skipline(11);
		}
	}

	finalisemodel();
}

filter(type="importmodel", name="GAMESS-US Cartesian Input", nickname="gamusinp", extension="inp", glob="*.inp", zmap="name", id=5)
{
	# Variables
	string symm,symbol,title;
	int n,z;
	double rx,ry,rz;

	# Search for $DATA section
	if (!find("DATA")) error("Couldn't find 'DATA' section in input file.");

	# Read in title card
	getline(title);
	newmodel(title);

	# Skip over symmetry specification
	readline(symm);
	if (symm <> "C1")
	{
		# Single blank line means the master frame is in use, and only this line to skip
		readline(symm);
		if (symm != "") skipline();
	}
	
	# Coordinates follow, terminated by $END
	readline(symbol,z,rx,ry,rz);
	while (symbol != "$END")
	{
		newatom(symbol,rx,ry,rz);
		readline(symbol,z,rx,ry,rz);
	}

	# Done
	rebond();
	finalisemodel();
}

filter(type="exportmodel", name="GAMESS-US Cartesian Input", nickname="gamusinp", extension="inp", glob="*.inp", id=5)
{
	#
	# GUI Control Definitions
	#

	# General control options ($CONTRL)
	string runtyp = option("Run Type", "combo", "ENERGY,GRADIENT,HESSIAN,GAMMA,OPTIMIZE,TRUDGE,SADPOINT,MEX,IRC,VSCF,DRC,MD,GLOBOP,OPTFMO,GRADEXTR,SURFACE,G3MP2,PROP,RAMAN,NACME,NMR,EDA,TRANSITN,FFIELD,TDHF,TDHFX,MAKEFP,FMO0", 5, "group=Job Control ($CONTRL)");
	string scftyp = option("SCF Type", "combo", "RHF,UHF,ROHF,GVB,MCSCF,NONE", 1, "group=Job Control ($CONTRL)");
	int mult = option("Multiplicity", "intspin", 1, 8, 1, 1, "group=Job Control ($CONTRL)");
	int charge = option("Charge", "intspin", -1000, 1000, 0, 1, "group=Job Control ($CONTRL)");
	string dfttyp = option("DFT Type", "combo", "NONE,'SVWN (...local DFT)','BLYP (...pure DFT GGA)',PW91,B97-D,PBE,PBEsol,'B3LYP (...hybrid DFT GGA)',X3LYP,PBE0,'TPSS (...pure DFT meta-GGA)',TPSSm,'TPSSh (...hybrid DFT meta-GGA)',M06,'SLATER (...pure exchange)',BECKE,GILL,OPTX,PW91X,PBEX,'VWN (...pure correlation)',VWN1,PZ81,P86,LYP,PW91C,PBEc,OP,'SVWN (...combinations)',BLYP,BOP,BP86,GVWN,GPW91,PBEVWN,PBEOP,OLYP,PW91,PBE", 1, "group=Job Control ($CONTRL)", "newline");
	string tddft = option("TDDFT Type", "combo", "NONE,EXCITE", 1, "group=Job Control ($CONTRL)");
	string mplevl = option("MP Level", "combo", "0,2", 1, "group=Job Control ($CONTRL)");
	string cityp = option("CI Type", "combo", "NONE,CIS,ALDET,ORMAS,FSOCI,GENCI,GUGA", 1, "group=Job Control ($CONTRL)");
	string cctyp = option("CC Type", "combo", "NONE,LCCD,CCD,CCSD,CCSD(T),R-CC,CR-CC,CR-CCL,CCSD(TQ),CR-CC(Q),EOM-CCSD,CR-EOM,CR-EOML,IP-EOM2,EA-EOM2,EA-EOM3A", 1, "group=Job Control ($CONTRL)", "newline");
	string relwfn = option("Rel. Wfn.", "combo", "NONE,DK,RESC,NESC", 1, "group=Job Control ($CONTRL)");
	string exetyp = option("Exe Type", "combo", "RUN,CHECK,DEBUG", 1, "group=Job Control ($CONTRL)");
	string pp = option("Pseudo", "combo", "NONE,READ,SBKJC,HW,MCP", 1, "group=Job Control ($CONTRL)");

	# Basis set specification ($BASIS)
	string basis_gbasis = option("Basis", "combo", "MINI,MIDI,STO,N21,N31,N311,DZV,DH,TZV,MC,CCD,CCT,CCQ,CC5,CC6,ACCD,ACCT,ACCQ,ACC5,ACC6,CCDC,CCTC,CCQC,CC5C,CC6C,ACCDC,ACCTC,ACCQC,ACC5C,ACC6C,PC0,PC1,PC2,PC3,PC4,APC0,APC1,APC2,APC3,APC4,SBKJC,HW,MCP-DZP,MCP-TZP,MCP-QZP,IMCP-SR1,IMCP-SR2,IMCP-NR1,IMCP-NR2,MNDO,AM1,PM3", 5, "group=Basis Set ($BASIS)", "newline");
	int basis_ngauss = option("NGAUSS", "intspin", 3,8,6,1, "group=Basis Set ($BASIS)");
	int basis_ndfunc = option("NDFUNC", "intspin", 0,3,0,1, "group=Basis Set ($BASIS)");
	int basis_npfunc = option("NPFUNC", "intspin", 0,3,0,1, "group=Basis Set ($BASIS)");
	int basis_nffunc = option("NFFUNC", "intspin", 0,1,0,1, "group=Basis Set ($BASIS)");
	string basis_diffsp = option("DIFFSP", "combo", ".TRUE.,.FALSE.", 2, "group=Basis Set ($BASIS)");
	string basis_diffs = option("DIFFS", "combo", ".TRUE.,.FALSE.", 2, "group=Basis Set ($BASIS)");

	# DFT options ($DFT), placed in 'opts' tab
	string dftgrid = option("DFT Method", "combo", "GRID,GRIDFREE", 1, "state=GRID@DFT Type?originalitems", "state=GRIDFREE@DFT Type?items=NONE,XALPHA,SLATER,BECKE,DEPRISTO,CAMA,HALF,VWN,PWLOC,LYP,BVWN,BLYP,BPWLOC,B3LYP,CAMB,XVWN,XPWLOC,SVWN,SPWLOC,WIGNER,WS,WIGEXP", "tab=$DFT@opts", "newline");

	# Stationary point location options ($STATPT), placed in 'opts' tabs
	string statpt_method = option("Method", "combo", "NR,RFO,QA,SCHLEGEL,CONOPT", 3, "tab=$STATPT@opts", "newline");
	double statpt_opttol = option("Tolerance", "doublespin", 0.0, 1.0, 0.0001, 0.0001, "tab=$STATPT@opts");
	int statpt_nstep = option("NStep", "intspin", 1, 1000000, 20, 5, "tab=$STATPT@opts");

	# Electron density calculation ($ELDENS), placed in 'opts' tabs
	int eldens_ieden = option("Calculate", "check", 0, "tab=$ELDENS@opts", "newline");
	int eldens_morb = option("MORB", "intspin", 0, 10000, 0, 1, "tab=$ELDENS@opts");
	string eldens_where = option("WHERE", "combo", "COMASS,NUCLEI,POINTS,GRID", 2, "tab=$ELDENS@opts");
	string eldens_output = option("OUTPUT", "combo", "PUNCH,PAPER,BOTH", 3, "tab=$ELDENS@opts");

	# Electrostatic potential calculation ($ELPOT), placed in 'opts' tabs
	int elpot_iepot = option("Calculate", "check", 0, "tab=$ELPOT@opts", "newline");
	string elpot_where = option("WHERE", "combo", "COMASS,NUCLEI,POINTS,GRID,PDC", 2, "tab=$ELPOT@opts");
	string elpot_output = option("OUTPUT", "combo", "PUNCH,PAPER,BOTH,NONE", 3, "tab=$ELPOT@opts");

	# Grid specification ($GRID), placed in 'opts' tabs
	int grid_modgrd = option("3D Grid", "check", 0, "tab=$GRID@opts", "newline");
	double grid_size = option("Grid Increment", "doublespin", 0.00001, 2.0, 0.25, 0.1, "tab=$GRID@opts");
	option("ORIGIN", "label", "newline", "tab=$GRID@opts");
	double grid_originx = option("X", "doublespin", -1000.0, 1000, -10.0, 1, "tab=$GRID@opts");
	double grid_originy = option("Y", "doublespin", -1000.0, 1000, -10.0, 1, "tab=$GRID@opts");
	double grid_originz = option("Z", "doublespin", -1000.0, 1000, -10.0, 1, "tab=$GRID@opts");
	option("XVEC", "label", "newline", "tab=$GRID@opts");
	double grid_xvecx = option("X", "doublespin", -1000.0, 1000,  10.0, 1, "tab=$GRID@opts");
	double grid_xvecy = option("Y", "doublespin", -1000.0, 1000, -10.0, 1, "tab=$GRID@opts");
	double grid_xvecz = option("Z", "doublespin", -1000.0, 1000, -10.0, 1, "tab=$GRID@opts");
	option("YVEC", "label", "newline", "tab=$GRID@opts");
	double grid_yvecx = option("X", "doublespin", -1000.0, 1000,  10.0, 1, "tab=$GRID@opts");
	double grid_yvecy = option("Y", "doublespin", -1000.0, 1000, -10.0, 1, "tab=$GRID@opts");
	double grid_yvecz = option("Z", "doublespin", -1000.0, 1000, -10.0, 1, "tab=$GRID@opts");
	option("ZVEC", "label", "newline", "tab=$GRID@opts");
	double grid_zvecx = option("X", "doublespin", -1000.0, 1000,  10.0, 1, "tab=$GRID@opts");
	double grid_zvecy = option("Y", "doublespin", -1000.0, 1000, -10.0, 1, "tab=$GRID@opts");
	double grid_zvecz = option("Z", "doublespin", -1000.0, 1000, -10.0, 1, "tab=$GRID@opts");

	#
	# Write Data
	#

	# Write $CONTRL, $SYSTEM and $BASIS groups
	writelinef(" $CONTRL SCFTYP=%s RUNTYP=%s COORD=CART ICHARG=%i MULT=%i $END\n", scftyp, runtyp, charge, mult);
	writelinef(" $CONTRL DFTTYP=%s TDDFT=%s MPLEVL=%s CITYP=%s CCTYP=%s $END\n", beforestr(dfttyp," ",TRUE), tddft, mplevl, cityp, cctyp);
	writelinef(" $BASIS GBASIS=%s NGAUSS=%i NDFUNC=%i NPFUNC=%i $END\n", basis_gbasis, basis_ngauss, basis_ndfunc, basis_npfunc);
	writelinef(" $BASIS NFFUNC=%i DIFFSP=%s DIFFS=%s $END\n", basis_nffunc, basis_diffsp, basis_diffs);
	if ((runtyp == "OPTIMIZE") || (runtyp == "SADPOINT")) writelinef(" $STATPT METHOD=%s NSTEP=%i OPTTOL=%f $END\n", statpt_method, statpt_nstep, statpt_opttol);
	writeline(" $SYSTEM MEMDDI=16 TIMLIM=2400 MWORDS=96 $END");
	writeline(" $GUESS GUESS=HUCKEL $END");
	writeline(" $SCF DIRSCF=.TRUE. $END");

	# Write $ELDENS if required
	if (eldens_ieden == 1) writelinef(" $ELDEN IEDEN=1 MORB=%i WHERE=%s OUTPUT=%s $END\n", eldens_morb, eldens_where, eldens_output);

	# Write $ELPOT if required
	if (elpot_iepot == 1) writelinef(" $ELPOT IEPOT=1 WHERE=%s OUTPUT=%s $END\n", elpot_where, elpot_output);

	# Write $GRID if required
	if ((eldens_where == "GRID") || (elpot_where == "GRID"))
	{
		writelinef(" $GRID MODGRD=%i UNITS=ANGS SIZE=%f $END\n", grid_modgrd, grid_size);
		writelinef(" $GRID ORIGIN(1)=%f ORIGIN(2)=%f ORIGIN(3)=%f $END\n", grid_originx, grid_originy, grid_originz);
		writelinef(" $GRID XVEC(1)=%f XVEC(2)=%f XVEC(3)=%f $END\n", grid_xvecx, grid_xvecy, grid_xvecz);
		writelinef(" $GRID YVEC(1)=%f YVEC(2)=%f YVEC(3)=%f $END\n", grid_yvecx, grid_yvecy, grid_yvecz);
		if (grid_modgrd == 1) writelinef(" $GRID ZVEC(1)=%f ZVEC(2)=%f ZVEC(3)=%f $END\n", grid_zvecx, grid_zvecy, grid_zvecz);
	}

	# Now for the DATA section
	writeline(" $DATA");
	writeline(aten.frame.name);
	writeline("C1");
	for (atom i = aten.frame.atoms; i != 0; ++i) writelinef("%-15s  %4.1f  %12.6f %12.6f %12.6f\n", i.name,i.z*1.0,i.rx,i.ry,i.rz);
	writeline(" $END");
}

# Quantum Espresso
# Created:	 22/06/2010
# Last modified: 24/04/2012
# ChangeLog:
#	24/04/2012 - Fixed exportmodel filter - cell information and format is now correct
#	02/09/2011 - Tweaked to use capitalised command/member names in v1.8
# Notes:
#	Lattice type of cell is not accounted for (ibrav=0)

filter(type="exportmodel", name="Quantum Espresso Input", nickname="espresso", extension="in", glob="*.in", id=15)
{
	# Variable declaration
	int n, el[aten.nElements], nspecies;
	string e;
	double rx,ry,rz;
	atom i;

	# Grab current model (or frame)
	model m = aten.frame;

	# Determine number of species (elements) used in model, and create element->species map
	el = 0;
	nspecies = 0;
	for (i = m.atoms; i; ++i) if (el[i.z] == 0) el[i.z] = ++nspecies;
	
	# Write 'control', 'system', 'electrons', 'ions', and 'cell' sections
	writeLine("&control");
	writeLine("   calculation='vc-relax',");
	writeLine("   tstress=.true.,");
	writeLine("   pseudo_dir='/home/user/src/espresso-4.3.2/pseudo'");
	writeLine("/");
	writeLine("&system");
	writeLine("   ibrav=0,");
	if (m.cell.type != "none") writeLineF("   celldm(1)=%f,\n", m.cell.a/ANGBOHR);
	writeLineF("   nat=%i,\n",m.nAtoms);
	writeLineF("   ntyp=%i,\n",nspecies);
	writeLine("   ecutwfc=50.0,");
	writeLine("   ecutrho=200.0,");
	writeLine(" /");
	writeLine(" &electrons");
	writeLine("   mixing_beta=0.25,");
	writeLine("   conv_thr=1.0e-8");
	writeLine(" /");
	writeLine(" &IONS");
	writeLine("   ion_positions='from_input'");
	writeLine(" /");
	writeLine(" &cell");
	writeLine("   cell_dynamics='bfgs',");
	writeLine("   press=0.0");
	writeLine(" /");

	# Write cell data
	if (m.cell.type != "none")
	{
		writeLine("CELL_PARAMETERS");
		double alat = m.cell.a;
		writeLineF("    %f %f %f\n", m.cell.ax/alat, m.cell.ay/alat, m.cell.az/alat);
		writeLineF("    %f %f %f\n", m.cell.bx/alat, m.cell.by/alat, m.cell.bz/alat);
		writeLineF("    %f %f %f\n", m.cell.cx/alat, m.cell.cy/alat, m.cell.cz/alat);
	}

	# Write atomic species data
	writeLine("ATOMIC_SPECIES");
	for (n=1; n<=aten.nElements; n++) if (el[n] != 0) writeLineF("%-5s  %10.4f  %s.UPF\n",aten.elements[n].symbol, aten.elements[n].mass, aten.elements[n].symbol);

	# Write atomic positions data
	writeLine("ATOMIC_POSITIONS {angstrom}");
	for (i = m.atoms; i; ++i) writeLineF("%-5s   %14.8f %14.8f %14.8f\n",i.symbol,i.rx,i.ry,i.rz);
}

# Subroutines for output-file reading

# Read next occurrence of unit cell (PWSCF)
int readPWCell(UnitCell ucell, double alat, string alatKeywd)
{
	string s = "crystal axes: (cart. coord. in units of " + alatKeywd + ")";
	if (!find(s)) return FALSE;
	if (!readLineF("%23* %f %f %f", ucell.ax,ucell.ay,ucell.az)) return 0;
	if (!readLineF("%23* %f %f %f", ucell.bx,ucell.by,ucell.bz)) return 0;
	if (!readLineF("%23* %f %f %f", ucell.cx,ucell.cy,ucell.cz)) return 0;
	for (int n=1; n<=9; ++n) ucell.matrix[n] *= alat;
	return TRUE;
}

# Read next occurrence of unit cell (CP)
int readCPCell(UnitCell ucell)
{
	if (!find(" alat  = ")) return FALSE;
	if (!readLineF("%* $* %f %f %f", ucell.ax,ucell.ay,ucell.az)) return 0;
	if (!readLineF("%* $* %f %f %f", ucell.bx,ucell.by,ucell.bz)) return 0;
	if (!readLineF("%* $* %f %f %f", ucell.cx,ucell.cy,ucell.cz)) return 0;
	return TRUE;
}

# Read atomic coordinates (PWSCF)
int readPWAtoms(Model m, int nAtoms, double alat, string alatKeywd)
{
	string s = "site n.     atom                  positions (" + alatKeywd + " units)";
	if (!find(s)) return FALSE;
	string el;
	double x, y, z;
	for (int n=0; n<nAtoms; ++n)
	{
		readLineF("%12*%10s%16*%f %f %f", el, x, y, z);
		m.newAtom(el, x*alat, y*alat, z*alat);
	}
	return TRUE;
}

# Read atomic forces (PWSCF)
int readPWForces(Model m)
{
	if (!find("Forces acting on atoms (Ry/au):") ) return FALSE;
	skipLine();
	Vector f;
	double conv = (13.60569253*96.4853365)/ANGBOHR;
	for (int n=1; n<=m.nAtoms; ++n)
	{
		readLineF("%*%*%*%*%*%*%f%f%f",f.x, f.y, f.z);
		# Forces in Ry/au, so convert to kJ/mol/Angstrom
		f *= conv;
		m.atoms[n].f = f;
	}
}

# Read next occurrence of unit cell (PWSCF frame)
int readPWCellFrame(UnitCell ucell, double alat, string alatKeywd)
{
	string s = "new lattice vectors (" + alatKeywd + " units)";
	if (!find(s)) return FALSE;
	if (!readLineF("%23* %f %f %f", ucell.ax,ucell.ay,ucell.az)) return 0;
	if (!readLineF("%23* %f %f %f", ucell.bx,ucell.by,ucell.bz)) return 0;
	if (!readLineF("%23* %f %f %f", ucell.cx,ucell.cy,ucell.cz)) return 0;
	for (int n=1; n<=9; ++n) ucell.matrix[n] *= alat;
	return TRUE;
}

# Read atomic coordinates (PWSCF frame)
int readPWAtomsFrame(Model m, int nAtoms)
{
	if (!find("new positions in cryst coord")) return FALSE;
	string el;
	double x, y, z;
	for (int n=0; n<nAtoms; ++n)
	{
		readLineF("%12*%10s%16*%f %f %f", el, x, y, z);
		m.newAtomFrac(el, x, y, z);
	}
	return TRUE;
}

int readAtoms(int nAtoms)
{
	double x,y,z;
	string el;
	for (int n=0; n<nAtoms; ++n)
	{
		if (!readLine(el,x,y,z)) return 0;
		newAtom(el,x,y,z);
	}
	return 1;
}

filter(type="importmodel", name="Quantum Espresso Output (PWSCF)", nickname="qepwscf", extension="out", glob="*.out", search="PWSCF")
{
	# Variable declaration
	int nAtoms, nConfigs = 1, atomForces = FALSE;
	string keywd, discard, line, alatKeywd;
	UnitCell ucell = new UnitCell;
	double alat;
	removeReadOption("skipblanks");

	# Locate lattice coordinate and number of atoms
	if (find("lattice parameter", line))
	{
		addReadOption("stripbrackets");
		readVar(line, discard, discard, alatKeywd, discard, alat);
		removeReadOption("stripbrackets");
		alat *= 0.52917720859;
		printf("Lattice parameter (%s) is %f Angstroms\n", alatKeywd, alat);
	}
	else printf("Failed to find lattice parameter.\n");

	# Find number of atoms per basic cell
	if (find("number of atoms/cell", line))
	{
		readVar(line,discard,discard,discard,discard,nAtoms);
		printf("Number of atoms in cell = %i\n", nAtoms); 
	}
	else error("Failed to find number of atoms in cell.");

	# Read initial cell and coordinates
	if (!readPWCell(ucell, alat, alatKeywd)) error("Failed to find any cell parameters");
	Model m = newModel(filterFilename());
	m.cell.copy(ucell);
	if (!readPWAtoms(m, nAtoms, alat, alatKeywd)) error("No atomic coordinates found.");
	# Atomic forces?
	atomForces = readPWForces(m);

	# Any other configurations, e.g. from geometry optimisation?
	while (!eof())
	{
		# Attempt to find new cell information
		if (!readPWCellFrame(ucell, alat, alatKeywd)) break;
		++nConfigs;
		m = addFrame(toa("Frame %i",nConfigs));
		m.cell.copy(ucell);
		if (!readPWAtomsFrame(m, nAtoms))
		{
			printf("Failed to find atom coordinates for frame %i\n", nConfigs);
			finaliseFrame();
			break;
		}
		# Atomic forces?
		if (atomForces) readPWForces(m);
		finaliseFrame();
	}
	finaliseModel();
}


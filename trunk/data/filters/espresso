# Quantum Espresso
# Created:	 22/06/2010
# Last modified: 02/09/2011
# ChangeLog:
#	02/09/2011 - Tweaked to use capitalised command/member names in v1.8
# Notes:
#	Lattice type of cell is not accounted for (ibrav=0)

filter(type="exportmodel", name="Quantum Espresso Input", nickname="espresso", extension="in", glob="*.in", id=15)
{
	# Variable declaration
	int n, el[aten.nElements], nspecies;
	string e;
	double rx,ry,rz;
	atom i;

	# Grab current model (or frame)
	model m = aten.frame;

	# Determine number of species (elements) used in model, and create element->species map
	el = 0;
	nspecies = 0;
	for (i = m.atoms; i; ++i) if (el[i.z] == 0) el[i.z] = ++nspecies;
	
	# Write 'control', 'system', 'electrons', 'ions', and 'cell' sections
	writeLine("&control");
	writeLine("   calculation='vc-relax',");
	writeLine("   tstress=.true.,");
	writeLine("   pseudo_dir='/home/user/src/espresso-4.3.2/pseudo'");
	writeLine("/");
	writeLine("&system");
	writeLine("   ibrav=0,");
	if (m.cell.type != "none") writeLineF("  celldm(1)=%f,\n", m.cell.a/ANGBOHR);
	writeLineF("   nat=%i,\n",m.nAtoms);
	writeLineF("   ntyp=%i,\n",nspecies);
	writeLine("   ecutwfc=50.0,");
	writeLine("   ecutrho=200.0,");
	writeLine(" /");
	writeLine(" &electrons");
	writeLine("   mixing_beta=0.25,");
	writeLine("   conv_thr=1.0e-8");
	writeLine(" /");
	writeLine(" &IONS");
	writeLine("   ion_positions='from_input'");
	writeLine(" /");
	writeLine(" &cell");
	writeLine("   cell_dynamics='bfgs',");
	writeLine("   press=0.0");
	writeLine(" /");

	# Write cell data
	if (m.cell.type != "none")
	{
		writeLine("CELL_PARAMETERS");
		double alat = m.cell.a;
		writeLineF("    %f %f %f\n", m.cell.ax/alat, m.cell.ay/alat, m.cell.az/alat);
		writeLineF("    %f %f %f\n", m.cell.bx/alat, m.cell.by/alat, m.cell.bz/alat);
		writeLineF("    %f %f %f\n", m.cell.cx/alat, m.cell.cy/alat, m.cell.cz/alat);
	}

	# Write atomic species data
	writeLine("ATOMIC_SPECIES");
	for (n=1; n<=aten.nElements; n++) if (el[n] != 0) writeLineF("%-5s  %10.4f  %s.UPF\n",aten.elements[n].symbol, aten.elements[n].mass, aten.elements[n].symbol);

	# Write atomic positions data
	writeLine("ATOMIC_POSITIONS {angstrom}");
	for (i = m.atoms; i; ++i) writeLineF("%-5s   %14.8f %14.8f %14.8f\n",i.symbol,i.rx,i.ry,i.rz);
}

# Subroutines for output-file reading

# Read next occurrence of unit cell (PWSCF)
int readPWCell(double alat, UnitCell ucell)
{
	if (!find("crystal axes: (cart. coord. in units of a_0)")) return FALSE;
	Vector v1,v2,v3;
	if (!readLineF("%23* %f %f %f", ucell.ax,ucell.ay,ucell.az)) return 0;
	if (!readLineF("%23* %f %f %f", ucell.bx,ucell.by,ucell.bz)) return 0;
	if (!readLineF("%23* %f %f %f", ucell.cx,ucell.cy,ucell.cz)) return 0;
	for (int n=1; n<=9; ++n) ucell.matrix[n] *= alat;
	return TRUE;
}

# Read next occurrence of unit cell (CP)
int readCPCell(UnitCell ucell)
{
	if (!find(" alat  = ")) return FALSE;
	if (!readLineF("%* $* %f %f %f", ucell.ax,ucell.ay,ucell.az)) return 0;
	if (!readLineF("%* $* %f %f %f", ucell.bx,ucell.by,ucell.bz)) return 0;
	if (!readLineF("%* $* %f %f %f", ucell.cx,ucell.cy,ucell.cz)) return 0;
	return TRUE;
}

# Read coordinates (PWSCF)
int readPWAtoms(int nAtoms, double alat, Model m)
{
	if (!find("site n.     atom                  positions (a_0 units)")) return FALSE;
	String el;
	double x, y, z;
	for (int n=0; n<nAtoms; ++n)
	{
		readLineF("%12*%10s%16*%f %f %f",  el, x, y, z);
		m.newAtom(el, x*alat, y*alat, z*alat);
	}
	return TRUE;
}

int readAtoms(int nAtoms)
{
	double x,y,z;
	string el;
	for (int n=0; n<nAtoms; ++n)
	{
		if (!readLine(el,x,y,z)) return 0;
		newAtom(el,x,y,z);
	}
	return 1;
}

filter(type="importmodel", name="Quantum Espresso Output (PWSCF)", nickname="qepwscf", extension="out", glob="*.out", search="PWSCF")
{
	# Variable declaration
	int nAtoms, nConfigs = 1, cellType = 0, coordType = 0;
	string keywd,data,line,unit;
	UnitCell ucell = new UnitCell;
	double alat;

	# Locate lattice coordinate and number of atoms
	if (find("lattice parameter (a_0)", line))
	{
		readVar(line,data,data,data,data,alat);
		alat *= 0.52917720859;
		printf("Lattice parameter is %f Angstroms\n", alat);
	}
	else printf("Failed to find lattice parameter.\n");

	# Find number of atoms per basic cell
	if (find("number of atoms/cell", line))
	{
		readVar(line,data,data,data,data,nAtoms);
		printf("Number of atoms in cell = %i\n", nAtoms); 
	}
	else error("Failed to find number of atoms in cell.");

	# Read initial cell and coordinates
	if (!readPWCell(alat,ucell)) error("Failed to find any cell parameters");
	Model m = newModel(filterFilename());
	m.cell.copy(ucell);
	#if (!find("ATOMIC_POSITIONS")) error("Failed to find any coordinates");
	#if (!readAtoms(nAtoms)) error("Error reading atomic positions");
	if (!readPWAtoms(nAtoms, alat, m)) error("No atomic coordinates found.");
	
	# Any others?
	while (!eof())
	{
		# Search for first set of coordinates
		if (!find("CELL_PARAMETERS")) break;
		nConfigs++;
		addFrame(toa("Frame %i",nConfigs));
		#if (!readCell(alat)) error("Error reading cell parameters for configuration %i", nConfigs);
		if (!find("ATOMIC_POSITIONS")) error("Failed to find any coordinates for configuration %i", nConfigs);
		if (!readAtoms(nAtoms)) error("Error reading atomic positions for configuration %i", nConfigs);
		finaliseFrame();
	}
	finaliseModel();
}


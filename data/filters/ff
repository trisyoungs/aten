# Import/Export for Aten-format Forcefield File (BETA)
# Created:	 23/02/2011
# Last modified: 13/10/2015
# ChangeLog:
#	13/10/2015 - Added stub filter for FF import
#	02/09/2011 - Tweaked to use capitalised command/member names in v1.8
#	23/02/2011 - Initial version.

filter(type="importexpression",name="Aten Forcefield Format", extension="ff", glob="*.ff", nickname="ff")
{
	loadFF(filterFilename());
}

filter(type="exportexpression",name="Aten Forcefield Format", extension="ff", glob="*.ff", nickname="ff")
{
	# Variable declaration
        Pattern p;
	Atom i;
	FFBound b;
	FFAtom fi;
	double escale = 1.0, vscale = 1.0;
	int uselj = TRUE, n, nconstraints, nfailed[3] = 0, nub, hasub;
	string forms, currentform;
	
	# Get current model
	Model m = aten.frame;

	# Write header
	writeLineF("name \"%s\"\n", m.name());
	writeLineF("units %s\n\n", aten.prefs.energyUnit);

	# Write types information
	writeLine("types");
	for (fi in m.ffTypes) writeLineF("%5i\t%s\t%s\t\"%s\"\t\"%s\"\n", fi.id, fi.name, aten.elements[fi.z].symbol, fi.neta, fi.description);
	writeLine("end");

	# Write short-range information
	forms = "";
	while (1)
	{
		# Search for next functional form type used
		currentform = "";
		for (fi in m.ffTypes) if (!contains(forms, "___"+fi.form+"___")) { currentform = fi.form; break; }
		if (currentform == "") break;
		
		# Write out forms of this type
		writeLineF("\ninter %s\n", currentform);
		for (fi in m.ffTypes)
		{
			if (fi.form != currentform) continue;
			writeLineF("%5i\t%s\t%12.6f", fi.id, fi.name, fi.charge);
			for (n=1; n<=fi.nParams; ++n) writeLineF(" %12.6f", fi.data[n]);
			writeLineF("\n");
		}
		writeLine("end");

		# Add form to list
		forms += " ___"+currentform+"___ ";
	}

	# Write bond information
	forms = "";
	while (1)
	{
		# Search for next functional form type used
		currentform = "";
		for (b in m.ffBonds) if (!contains(forms, "___"+b.form+"___")) { currentform = b.form; break; }
		if (currentform == "") break;
		
		# Write out forms of this type
		writeLineF("\nbonds %s\n", currentform);
		for (b in m.ffBonds)
		{
			if (b.form != currentform) continue;
			writeLineF("%s\t%s\t", b.typeNames[1], b.typeNames[2]);
			for (n=1; n<=b.nParams; ++n) writeLineF(" %12.6f", b.data[n]);
			writeLineF("\n");
		}
		writeLine("end");

		# Add form to list
		forms += " ___"+currentform+"___ ";
	}

	# Write angle information
	forms = "";
	while (1)
	{
		# Search for next functional form type used
		currentform = "";
		for (b in m.ffAngles) if (!contains(forms, "___"+b.form+"___")) { currentform = b.form; break; }
		if (currentform == "") break;
		
		# Write out forms of this type
		writeLineF("\nangles %s\n", currentform);
		for (b in m.ffAngles)
		{
			if (b.form != currentform) continue;
			writeLineF("%s\t%s\t%s\t", b.typeNames[1], b.typeNames[2], b.typeNames[3]);
			for (n=1; n<=b.nParams; ++n) writeLineF(" %12.6f", b.data[n]);
			writeLineF("\n");
		}
		writeLine("end");

		# Add form to list
		forms += " ___"+currentform+"___ ";
	}

	# Write torsion information
	forms = "";
	while (1)
	{
		# Search for next functional form type used
		currentform = "";
		for (b in m.ffTorsions) if (!contains(forms, "___"+b.form+"___")) { currentform = b.form; break; }
		if (currentform == "") break;
		
		# Write out forms of this type
		writeLineF("\ntorsions %s\n", currentform);
		for (b in m.ffTorsions)
		{
			if (b.form != currentform) continue;
			writeLineF("%s\t%s\t%s\t%s\t", b.typeNames[1], b.typeNames[2], b.typeNames[3], b.typeNames[4]);
			for (n=1; n<=b.nParams; ++n) writeLineF(" %12.6f", b.data[n]);
			writeLineF("\n");
		}
		writeLine("end");

		# Add form to list
		forms += " ___"+currentform+"___ ";
	}
}


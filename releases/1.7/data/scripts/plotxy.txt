# Simple plot example, rendering a function over a regular 2D grid using triangle glyphs

double deltax = PI/5.0, deltay = PI/5.0;
int nx = 50, ny = 50, ix, iy;

double x, y, fxy, slice1[2*ny+1], slice2[2*ny+1], r, g, b, a;

aten.prefs.glyphcolour = { 0, 0, 1, 0.5 };
model m = newmodel("Function Plot");
glyph gl;

# Set up a colourscale to colour the plot nicely
colourscale cs = aten.prefs.colourscales[8];
cs.clear();
cs.addpoint(0.0,1,1,1,1.0);
cs.addpoint(2.0,0,0,1,1.0);

# Double loop begins
for (ix = 0; ix <= 2*nx; ++ix)
{
	x = (ix-nx) * deltax;

	# Calculate slice of values at fixed x
	for (iy = 0; iy <= 2*ny; ++iy)
	{
		y = (iy-ny) * deltay;

		# ***
		# Function to plot goes in here!
		# ***
		#fxy = 100*sin(x)*sin(y);
		#fxy = cos(abs(x)+abs(y))*(abs(x)+abs(y));
		fxy = sin(10.0*(x^2+y^2));
		# ***

		slice2[iy+1] = fxy;
	}

	# Generate glyphs (only if not first iteration of ix)
	if (ix > 0)
	{

		for (iy = 1; iy <=2*ny; ++iy)
		{
			y = (iy-ny) * deltay;
			gl = m.newglyph("triangle");
			gl.data[1].vector = { x-deltax, y-deltay, slice1[iy] };
			cs.colour(slice1[iy], r, g, b, a);
			gl.data[1].colour = { r, g, b, a };
			gl.data[2].vector = { x-deltax, y, slice1[iy+1] };
			cs.colour(slice1[iy+1], r, g, b, a);
			gl.data[2].colour = { r, g, b, a };
			gl.data[3].vector = { x, y-deltay, slice2[iy] };
			cs.colour(slice2[iy], r, g, b, a);
			gl.data[3].colour = { r, g, b, a };

			gl = m.newglyph("triangle");
			gl.data[1].vector = { x, y-deltay, slice2[iy] };
			cs.colour(slice2[iy], r, g, b, a);
			gl.data[1].colour = { r, g, b, a };
			gl.data[2].vector = { x-deltax, y, slice1[iy+1] };
			cs.colour(slice1[iy+1], r, g, b, a);
			gl.data[2].colour = { r, g, b, a };
			gl.data[3].vector = { x, y, slice2[iy+1] };
			cs.colour(slice2[iy+1], r, g, b, a);
			gl.data[3].colour = { r, g, b, a };
		}
	}

	# Copy slice2[] values into slice1[] for next pass
	for (iy = 0; iy <=2*ny; ++iy) slice1[iy+1] = slice2[iy+1];
}

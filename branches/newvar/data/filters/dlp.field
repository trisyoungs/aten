# Forcefield output suitable for DL_POLY (FIELD files).
# Last modified: 12/10/2008
# ChangeLog:
#	12/10/2008 - Fixed to use new variable access rules, and to write constraint terms.
#	04/10/2008 - Format delimiter reverted from '%' to '@'.
#	05/08/2008 - Quoting adjusted to follow new Parser rules in r550.

exportfield
	name "DL_POLY Forcefield Specification"
	nickname dlpoly
	extension FIELD
	glob *FIELD*
	exact "FIELD"

	# Variable declaration
	double epsilon, sigma
	pattern p
	atom i
	bound b
	ffatom at1, at2
	integer nvdw, n, m, nconstraints

	# First, write header consisting of title, energy units, and number of molecule types
	writeline "$model.name"
	if $prefs.energyunit = "kj"
		writeline "units  kj"
	elseif $prefs.energyunit = "kcal"
		writeline "units  kcal"
	elseif $prefs.energyunit = "ev"
		writeline "units  ev"
	else
		error "Current energy unit is not compatible with DL_POLY FIELD output"
	end
	writeline "molecules  $model.npatterns"

	# Loop over patterns (molecule types)
	for $p
		# Write pattern name and number of molecules
		writeline "$p.name"
		writeline "nummols  $p.nmols"
		# Write atoms - just loop over those in the first molecule of the pattern
		writeline "atoms  $p.nmolatoms"
		for $i $p 1
			writeline "$i.type.name@-8   $i.mass@10.5  $i.q@9.6   1   0   1"
		end
		# Bonds in pattern
		writeline "bonds  $p.nbonds"
		for $n,1,$p.nbonds
			# Grab bound pointer
			$b = $p.bonds[$n]
			# Convert functional form to be recognised by DL_POLY
			if $b.form = "harmonic"
				writeline "harm     $b.id[1]@5 $b.id[2]@5 $b.data[1]@10.4 $b.data[2]@10.4"
			elseif $b.form = "morse"
				writeline "morse    $b.id[1]@5 $b.id[2]@5 $b.data[3]@10.4 $b.data[2]@10.4 $b.data[1]@10.4"
			elseif $b.form = "constraint"
				# DL_POLY constraint terms are written in their own section
				$nconstraints += 1
			else
				warn "Functional form of bond term ($b.form) not accounted for in export filter."
				writeline "X$b.form $b.id[1]@5 $b.id[2]@5 $b.data[1]@10.4 $b.data[2]@10.4 $b.data[3]@10.4 $b.data[4]@10.4" 
			end
		end
		# Angles in pattern
		writeline "angles  $p.nangles"
		for $n,1,$p.nangles
			# Grab bound pointer
			$b = $p.angles[$n]
			# Convert functional form to be recognised by DL_POLY
			if $b.form = "harmonic"
				writeline "harm     $b.id[1]@5 $b.id[2]@5 $b.id[3]@5 $b.data[1]@10.4 $b.data[2]@10.4"
			elseif $b.form = "cos"
				writeline "cos      $b.id[1]@5 $b.id[2]@5 $b.id[3]@5 $b.data[1]@10.4 $b.data[3]@10.4 $b.data[2]@10.4"
			elseif $b.form = "harmcos"
				writeline "hcos     $b.id[1]@5 $b.id[2]@5 $b.id[3]@5 $b.data[1]@10.4 $b.data[2]@10.4"
			elseif $b.form = "bondconstraint"
				$nconstraints += 1
			else
				warn "Functional form of angle term ($b.form) not accounted for in export filter."
				writeline "X$b.form     $b.id[1]@5 $b.id[2]@5 $b.id[3]@5 $b.data[1]@10.4 $b.data[2]@10.4 $b.data[3]@10.4 $b.data[4]@10.4 $b.data[5]@10.4 $b.data[6]@10.4"
			end
		end
		# Torsions in pattern
		writeline "dihedrals  $p.ntorsions"
		for $n,1,$p.ntorsions
			# Grab bound pointer
			$b = $p.torsions[$n]
			# Convert functional form to be recognised by DL_POLY
			if $b.form = "cos"
				writeline "cos    $b.id[1]@5 $b.id[2]@5 $b.id[3]@5 $b.id[4]@5 $b.data[1]@10.4 $b.data[2]@10.4 $b.data[3]@10.4 $b.escale@10.4 $b.vscale@10.4"
			elseif $b.form = "cos3"
				writeline "cos3   $b.id[1]@5 $b.id[2]@5 $b.id[3]@5 $b.id[4]@5 $b.data[1]@10.4 $b.data[2]@10.4 $b.data[3]@10.4 $b.escale@10.4 $b.vscale@10.4"
			else
				warn "Functional form of torsion term ($b.form) not accounted for in export filter."
				writeline "X$b.form   $b.id[1]@5 $b.id[2]@5 $b.id[3]@5 $b.id[4]@5 $b.data[1]@10.4 $b.data[2]@10.4 $b.data[3]@10.4 $b.data[4]@10.4 $b.escale@10.4 $b.vscale@10.4"
			end
		end
		# Constraint terms
		writeline "constraints  $nconstraints"
		# ...proper bond constraints first
		for $n,1,$p.nbonds
			$b = $p.bonds[$n]
			if $b.form = "constraint"
				writeline "   $b.id[1]@5 $b.id[2]@5 $b.data[2]@10.6"
			end
		end
		# ...and now angles that are of type 'bondconstraint'
		for $n,1,$p.nangles
			$b = $p.angles[$n]
			if $b.form = "bondconstraint"
				writeline "   $b.id[1]@5 $b.id[3]@5 $b.data[2]@10.6"
			end
		end
		# Terminating line
		writeline "finish"
	end
	# VDW Specification
	# Get total number of pair terms to write
	let $nvdw = 0
	for $n,1,$model.natomtypes
		$nvdw += $n
	end 
	writeline "nvdw  $nvdw"
	for $n,1,$model.natomtypes
		$at1 = $model.atomtypes[$n]
		for $m,1,$n
			$at2 = $model.atomtypes[$m]
			# Check functional forms of each atomtype
			if $at1.form <> $at2.form
				warn "Functional forms of atomtypes '$at1.name' and '$at2.name' differ - raw data written to output..." 
				writeline "$at1.name@-8  $at2.name@-8   $at1.data[1]@12.6  $at1.data[2]@12.6  $at1.data[3]@12.6 $at1.data[4]@12.6 $at1.data[5]@12.6 $at1.data[6]@12.6"
			elseif $at1.form = lj
				# LJ: use Lorentz-Berthelot combination rules
				$sigma = '($at1.data[2] + $at2.data[2]) * 0.5'
				$epsilon = '($at1.data[1] * $at2.data[1]) ^ 0.5'
				writeline "$at1.name@-8  $at2.name@-8  lj  $epsilon@12.6  $sigma@12.6"
			elseif $at1.form = buck
				error "Buckingham potential not included in FIELD file export yet."
			else
				warn "Functional form of VDW term ($at1.form) not accounted for in export filter."
			end
		end
	end
	writeline "close"
end

# DL_POLY Configuration Import / Export (for v1.2+)
# Created:	 25/03/2009
# Last modified: 10/04/2009
# ChangeLog:

filter(type="importmodel", name="DL_POLY Configuration", extension="CONFIG,REVCON,config,revcon", glob="*CON*",exact="CONFIG,REVCON,config,revcon",nickname="dlpoly",id=2)
{
	# Variable Declaration
	string e, title;
	int n,keytrj,imcon;
	double ax,ay,az,bx,by,bz,cx,cy,cz;
	double rx,ry,rz,vx,vy,vz,fx,fy,fz;

	# Title section
	getline(title);
	newmodel(title);
	readline(keytrj,imcon);

	# Cell (if present)
	if (imcon != 0)
	{
		readline(ax,ay,az);
		readline(bx,by,bz);
		readline(cx,cy,cz);
		cellaxes(ax,ay,az,bx,by,bz,cx,cy,cz);
	}

	# Atoms
	while (!eof())
	{
		readline(e);
		readline(rx,ry,rz);
		newatom(e,rx,ry,rz);
		if (keytrj > 0)
		{
			readline(vx,vy,vz);
			setvelocities(vx,vy,vz);
		}
		if (keytrj > 1)
		{
			readline(fx,fy,fz);
			setforces(fx,fy,fz);
		}
	}
	rebond();
	fold();
	finalisemodel();
}

filter(type="exportmodel", name="DL_POLY Configuration", extension="CONFIG,REVCON,config,revcon", glob="*CON*", exact="CONFIG,REVCON,config,revcon", nickname="dlpoly", id=2)
{
	# Variable Declaration
	int n,imcon;
	atom i;

	# Get current model
	model m = aten.frame;

	# Title section
	writeline(m.name);

	# Convert celltype string to DL_POLY-style integer
	if (m.cell.type == "none") imcon = 0;
	else if (m.cell.type == "cubic") imcon = 1;
	else if (m.cell.type == "orthorhombic") imcon = 2;
	else if (m.cell.type == "parallelepiped") imcon = 3;
	writelinef("%10i%10i\n",0,imcon);

	# Cell (if present) 
	if (imcon <> 0)
	{
		writelinef("%20.12f%20.12f%20.12f\n",m.cell.ax, m.cell.ay, m.cell.az);
		writelinef("%20.12f%20.12f%20.12f\n",m.cell.bx, m.cell.by, m.cell.bz);
		writelinef("%20.12f%20.12f%20.12f\n",m.cell.cx, m.cell.cy, m.cell.cz);
	}

	# Atoms
	for (n = 1; n <= m.natoms; ++n)
	{
		# Get variable pointer to make manipulation a little less cluttered
		i = m.atoms[n];
		if (i.type == 0) writelinef("%-8s%10i%20f\n",i.symbol,i.id,i.mass);
		else writelinef("%-8s%10i%20f\n",i.type.name,i.id,i.mass);
		writelinef("%20.14f%20.14f%20.14f\n",i.rx,i.ry,i.rz);
	}
}


filter(type="importtrajectory", name="DL_POLY Unformatted History", extension="HISu", glob="*HISu", exact="HISTORY", nickname="dlpolyu")
{
	# Since its a Fortran code, each record in the file is preceded and followed by an integer specifying
	# the record size in characters.

	int readheader()
	{
		int intsize=4, realsize=8, recsize;

		# First line is 80-character header.
		recsize = readint(intsize);
		if (recsize == 40)
		{
			printf("No header found in unformatted DL_POLY trajectory file. Assuming a restarted trajectory...\n");
			rewind();
			return TRUE;
		}
		else if (recsize != 80)
		{
			printf("File '%s' doesn't appear to be a DL_POLY Unformatted trajectory.\n", filterfilename());
			return FALSE;
		}
		string title = readchars(recsize);
		recsize = readint(intsize);

		# Next, number of atoms in the system (as a double)
		recsize = readint(intsize);
		int natoms = nint(readdouble());
		recsize = readint(intsize);

		# Atom names
		recsize = readint(intsize);
		skipchars(recsize);
		recsize = readint(intsize);

		# Atomic masses
		recsize = readint(intsize);
		skipchars(recsize);
		recsize = readint(intsize);

		# Atom charges
		recsize = readint(intsize);
		skipchars(recsize);
		recsize = readint(intsize);
		
		return TRUE;
	}

	int readframe()
	{
		int intsize=4, realsize=8, recsize;

		# Variables
		double mass,q,tstep;
		double axes[9];
		int natoms, nstep, keytrj, imcon, n;

		# First data for frame is : nstep, $natoms, keytrj, imcon, tstep, all as doubles 
		recsize = readint(intsize);
		if (recsize != 5*realsize) { printf("Error reading start of trajectory frame.\n"); return FALSE; }
		nstep = nint(readdouble(realsize));
		natoms = nint(readdouble(realsize));
		keytrj = nint(readdouble(realsize));
		imcon = nint(readdouble(realsize));
		tstep = readdouble(realsize);
		recsize = readint(intsize);
		verbose("nstep = %i, natoms = %i, keytrj = %i, imcon = %i, tstep = %f\n", nstep, natoms, keytrj, imcon, tstep);

		# Create temporary data arrays for reading
		double x[natoms], y[natoms], z[natoms];

		# Unit cell
		if (imcon != 0)
		{
			recsize = readint(intsize);
			if (recsize != 9*realsize) { printf("Error reading cell info from trajectory frame.\n"); return FALSE; }
			readdoublearray(axes,9);
			recsize = readint(intsize);
			cellaxes(axes[1],axes[2],axes[3],axes[4],axes[5],axes[6],axes[7],axes[8],axes[9]);
		}

		# Template atoms in parent model
		modeltemplate();
		if (aten.model.natoms != natoms) { printf("Parent model contains different number of atoms to trajectory - aborting.\n"); return FALSE; }

		# Coordinates
		recsize = readint(intsize);
		if (recsize != natoms*realsize) { printf("Error reading coordinate info from trajectory frame.\n"); return FALSE; }
		if (!readdoublearray(x,natoms)) { printf("Error reading x-coordinates from trajectory frame.\n"); return FALSE; }
		recsize = readint(intsize);
		recsize = readint(intsize);
		if (!readdoublearray(y,natoms)) { printf("Error reading y-coordinates from trajectory frame.\n"); return FALSE; }
		recsize = readint(intsize);
		recsize = readint(intsize);
		if (!readdoublearray(z,natoms)) { printf("Error reading z-coordinates from trajectory frame.\n"); return FALSE; }
		recsize = readint(intsize);
		for (n = 1; n<= natoms; ++n) setcoords(x[n], y[n], z[n], n);

		# Velocities
		if (keytrj > 0)
		{
			recsize = readint(intsize);
			if (recsize != natoms*realsize) { printf("Error reading velocity info from trajectory frame.\n"); return FALSE; }
			if (!readdoublearray(x,natoms)) { printf("Error reading x-velocities from trajectory frame.\n"); return FALSE; }
			recsize = readint(intsize);
			recsize = readint(intsize);
			if (!readdoublearray(y,natoms)) { printf("Error reading y-velocities from trajectory frame.\n"); return FALSE; }
			recsize = readint(intsize);
			recsize = readint(intsize);
			if (!readdoublearray(z,natoms)) { printf("Error reading z-velocities from trajectory frame.\n"); return FALSE; }
			recsize = readint(intsize);
			for (n = 1; n<= natoms; ++n) setvelocities(x[n], y[n], z[n], n);
		}

		# Forces
		if (keytrj > 1)
		{
			recsize = readint(intsize);
			if (recsize != natoms*realsize) { printf("Error reading force info from trajectory frame.\n"); return FALSE; }
			if (!readdoublearray(x,natoms)) { printf("Error reading x-forces from trajectory frame.\n"); return FALSE; }
			recsize = readint(intsize);
			recsize = readint(intsize);
			if (!readdoublearray(y,natoms)) { printf("Error reading y-forces from trajectory frame.\n"); return FALSE; }
			recsize = readint(intsize);
			recsize = readint(intsize);
			if (!readdoublearray(z,natoms)) { printf("Error reading z-forces from trajectory frame.\n"); return FALSE; }
			recsize = readint(intsize);
			for (n = 1; n<= natoms; ++n) setforces(x[n], y[n], z[n], n);
		}

		rebond();
		return TRUE;
	}
}

filter(type="importtrajectory", name="DL_POLY Formatted History", extension="HISf", glob="*HISf", exact="HISTORY", nickname="dlpolyf")
{
	int readheader()
	{
		string title;
		# DL_POLY formatted history files may contain a header.
		# Check first 8 characters of first line - if it reads 'timestep' then this trajectory doesn't have a header
		readlinef("%8s",title);
		if (title == "timestep")
		{
			printf("No header found in DL_POLY formatted trajectory. Assuming a restarted trajectory...\n");
			rewind();
		}
		else
		{
			# Next line contains keytrj, imcon, and natoms
			skipline();
		}
		return TRUE;
	}

	int readframe()
	{
		string title, e;
		int nstep, natoms, keytrj, imcon, n, id;
		vector x,y,z;
		double tstep, mass, q;

		# Frame header - '"timestep"	nstep	natms	keytrj	imcon	tstep'
		readlinef("%8s%10i%10i%10i%10i%12.6f", title, nstep, natoms, keytrj, imcon, tstep);

		# Check number of atoms in trajectory frame
		modeltemplate();
		if (aten.model.natoms != natoms) { printf("Parent model contains different number of atoms to trajectory - aborting.\n"); return FALSE; }

		# Read cell if its present
		if (imcon > 0)
		{
			readlinef("%12.4f%12.4f%12.4f",x.x, x.y, x.z);
			readlinef("%12.4f%12.4f%12.4f",y.x, y.y, y.z);
			readlinef("%12.4f%12.4f%12.4f",z.x, z.y, z.z);
			cellaxes(x.x, x.y, x.z, y.x, y.y, y.z, z.x, z.y, z.z);
		}

		# Now the atoms, velocities, and forces
		for (n=1; n<=natoms; ++n)
		{
			readlinef("%8s%10i%12.6f%12.6f", e, id, mass, q);
			readlinef("%12.4e%12.4e%f12.4e", x.x, x.y, x.z);
			setcoords(x.x, x.y, x.z, n);
			if (keytrj > 0)
			{
				readlinef("%12.4e%12.4e%f12.4e", x.x, x.y, x.z);
				setvelocities(x.x, x.y, x.z, n);
			}
			if (keytrj > 1)
			{
				readlinef("%12.4e%12.4e%f12.4e", x.x, x.y, x.z);
				setforces(x.x, x.y, x.z, n);
			}
		}
		rebond();
		return TRUE;
	}
}

filter(type="exportexpression",name="DL_POLY Forcefield Specification", extension="FIELD", glob="*FIELD",exact="FIELD",nickname="dlpoly")
{
	# Variable declaration
	double epsilon, sigma;
	pattern p;
	atom i;
	bound b;
	ffatom at1, at2;
	int nvdw, n,n2, nconstraints;
	model m = aten.model;

	# First, write header consisting of title, energy units, and number of molecule types
	writeline(m.name);
	if (aten.prefs.energyunit == "kj") writeline("units kj");
	else if (aten.prefs.energyunit == "kcal") writeline("units kcal");
	else if (aten.prefs.energyunit == "ev") writeline("units ev");
	else error("Current energy unit (%s) is not compatible with DL_POLY FIELD output.\n", aten.prefs.energyunit);

	writeline("molecules",m.npatterns);

	# Loop over patterns (molecule types)
	for (p = m.patterns; p; ++p)
	{
		nconstraints = 0;

		# Write pattern name and number of molecules
		writeline(p.name);
		writeline("nummols",p.nmols);

		# Write atoms - just loop over those in the first molecule of the pattern
		writeline("atoms",p.nmolatoms);
		i = p.firstatom;
		for (n=0; n<p.nmolatoms; ++n)
		{
			writelinef("%-8s   %10.5f  %9.6f   1   0   1\n",i.type.name,i.mass,i.q);
			++i;
		}

		# Bonds in pattern
		writeline("bonds",p.nbonds);
		for (n=1; n<=p.nbonds; ++n)
		{
			# Grab bound pointer
			b = p.bonds[n];
			# Convert functional form to be recognised by DL_POLY
			# Note: DL_POLY constraint terms are written in their own section
			if (b.form == "harmonic") writelinef("harm     %5i %5i %10.4f %10.4f\n",b.id[1],b.id[2],b.data[1],b.data[2]);
			else if (b.form == "morse") writelinef("morse    %5i %5i %10.4f %10.4f %10.4f\n",b.id[1],b.id[2],b.data[3],b.data[2],b.data[1]);
			else if (b.form == "constraint") nconstraints++;
			else
			{
				printf("Functional form of bond term (%s) not accounted for in export filter.\n",b.form);
				writelinef("X%s  %5i %5i %10.4f %10.4f %10.4f %10.4f\n",b.form,b.id[1],b.id[2],b.data[1],b.data[2],b.data[3],b.data[4]);
			}
		}

		# Angles in pattern
		writeline("angles",p.nangles);
		for (n=1; n<=p.nangles; ++n)
		{
			# Grab bound pointer
			b = p.angles[n];
			# Convert functional form to be recognised by DL_POLY
			if (b.form == "harmonic") writelinef("harm     %5i %5i %5i %10.4f %10.4f\n",b.id[1],b.id[2],b.id[3],b.data[1],b.data[2]);
			else if (b.form == "cos") writelinef("cos      %5i %5i %5i %10.4f %10.4f %10.4f\n",b.id[1],b.id[2],b.id[3],b.data[1],b.data[3],b.data[2]);
			else if (b.form == "harmcos") writelinef("hcos     %5i %5i %5i %10.4f %10.4f\n",b.id[1],b.id[2],b.id[3],b.data[1],b.data[2]);
			else if (b.form == "bondconstraint") nconstraints++;
			else
			{
				printf("Functional form of angle term (%s) not accounted for in export filter.\n",b.form);
				writelinef("X%s  %5i %5i %5i %10.4f %10.4f %10.4f %10.4f %10.4f %10.4f\n",b.form,b.id[1],b.id[2],b.id[3],b.data[1],b.data[2],b.data[3],b.data[4],b.data[5],b.data[6]);
			}
		}

		# Torsions in pattern
		writeline("dihedrals",p.ntorsions);
		for (n=1; n<=p.ntorsions; ++n)
		{
			# Grab bound pointer
			b = p.torsions[n];
			# Convert functional form to be recognised by DL_POLY
			if (b.form == "cos") writelinef("cos      %5i %5i %5i %5i %10.4f %10.4f %10.4f %10.4f %10.4f\n",b.id[1],b.id[2],b.id[3],b.id[4],b.data[1],b.data[2],b.data[3],b.escale,b.vscale);
			else if (b.form == "cos3") writelinef("cos3     %5i %5i %5i %5i %10.4f %10.4f %10.4f %10.4f %10.4f\n",b.id[1],b.id[2],b.id[3],b.id[4],b.data[1],b.data[2],b.data[3],b.escale,b.vscale);
			else
			{
				printf("Functional form of torsion term (%s) not accounted for in export filter.\n",b.form);
				writelinef("X%s     %5i %5i %5i %5i %10.4f %10.4f %10.4f %10.4f %10.4f\n",b.form,b.id[1],b.id[2],b.id[3],b.id[4],b.data[1],b.data[2],b.data[3],b.escale,b.vscale);
			}
		}
		# Constraint terms
		writeline("constraints",nconstraints);
		# ...proper bond constraints first
		for (n=1; n<=p.nbonds; ++n) if (p.bonds[n].form == "constraint") writelinef("    %5i %5i  %10.4f\n",b.id[1],b.id[2],b.data[2]);
		# ...and now angles that are of type 'bondconstraint'
		for (n=1; n<=p.nangles; ++n) if (p.angles[n].form == "bondconstraint") writelinef("    %5i %5i  %10.4f\n",b.id[1],b.id[3],b.data[2]);
		# Terminating line
		writeline("finish");
	}

	# VDW Specification
	# Get total number of pair terms to write
	nvdw = 0;
	for (n=1; n<=m.natomtypes; ++n) nvdw += n;
	writeline("nvdw",nvdw);
	for (n=1; n<=m.natomtypes; ++n)
	{
		at1 = m.atomtypes[n];
		for (n2=1; n2<=n; ++n2)
		{
			at2 = m.atomtypes[n2];
			# Check functional forms of each atomtype
			if (at1.form != at2.form)
			{
				printf("Functional forms of atomtypes '%s' and '%s' differ - raw data written to output...",at1.name,at2.name); 
				writelinef("%-8s  %-8s   %12.6f  %12.6f  %12.6f  %12.6f  %12.6f %12.6f\n",at1.name,at2.name,at1.data[1],at1.data[2],at1.data[3],at1.data[4],at1.data[5],at1.data[6]);
			}
			else if (at1.form == "lj")
			{
				# LJ: use Lorentz-Berthelot combination rules
				sigma = (at1.data[2] + at2.data[2]) * 0.5;
				epsilon = sqrt(at1.data[1] * at2.data[1]);
				writelinef("%-8s %-8s  lj  %12.6f  %12.6f\n",at1.name,at2.name,epsilon,sigma);
			}
			else if (at1.form == "buck") error("Buckingham potential not included in FIELD file export yet.\n");
			else printf("Functional form of VDW term (%s) not accounted for in export filter.\n",at1.form);
		}
	}
	writeline("close");
}

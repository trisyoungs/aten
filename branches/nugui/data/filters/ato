# Coordinate (ATO) file for Empirical Potential Structure Refinement (EPSR) software ( (C) Rutherford Appleton Labs )
# Created:	 23/03/2011
# Last modified: 23/03/2011
# ChangeLog:

filter(type="importmodel",name="EPSR ATO File", nickname="ato", extension="ato", glob="*.ato", id=18)
{
	// Variables
	atom i;
	int nmols,m,n,l,natoms,nres,nrot,count,done,id;
	element el;
	double boxsize, temp, eps, sigma, mass, q;
	string atomname, elname,line;
	vector com, r, phi;

	// File header:
	// 1 : nmols, box length, temperature
	if (!readline(nmols, boxsize, temp)) error("Failed to read header information from file.\n");
	newmodel("ATO file");
	cell(boxsize,boxsize,boxsize,90,90,90);

	// 2 : step sizes etc. (ignore)
	skipline();

	// Molecule/atom specifications are in the form:
	// n  : natoms, comx, comy, comz, phix, phiy, phiz
	// n+1: atom name 1
	// n+2: x,y,z (offsets from com)
	// n+3: nrestraints, res1, res2... (number of distance restraints, 5 per line)
	// n+4: ...resN-1, resN
	// n+5: nrot (number of defined molecular rotations)
	// n+6: atom1, atom2 (bonds of rotation 'axis')
	// n+7: list of headgroup atoms that are rotated
	count = 0;
	for (m=0; m<nmols; m++)
	{
		if (!readline(natoms, com.x, com.y, com.z, phi.x, phi.y, phi.z)) error("Error reading information for molecule %i.\n", m+1);

		for (n=0; n<natoms; n++)
		{
			// Basic atom information
			if (!readlinef(" %3s",atomname)) error("Error reading atom name %i for molecule %i\n", n+1, m+1);
			if (!readline(r.x, r.y, r.z)) error("Error reading atom coordinates %i for molecule %i\n", n+1, m+1);
			// Adjust for molecule centre of mass, and also apply a half-cell translation since EPSR uses -0.5 -> 0.5 coordinates
			r += com;
			r += boxsize/2.0;
			// Create a new atom with element 0 - it will be set to a proper element later on
			i = newatom(0, r.x, r.y, r.z);
			i.data = atomname;

			// Apply restraint information as bonds
			if (!nextarg(nres)) error("Error reading nrestraints for atom %i of molecule %i.\n", n+1, m+1);
			for (l=0; l<nres; ++l)
			{
				if (!nextarg(id) || !nextarg(temp)) error("Erro reading restraint information %i for atom %i of molecule %i.\n", l+1, n+1, m+1);
				// If the relative atom id is greater than the current atom number, ignore it (it will be repeated the other way around for the second atom)
				if (id > (n+1)) continue;
				newbond(count+n+1, count+id);
			}
			//skipline((nres-1) / 5);
		}

		// Discard molecular rotations
		if (!readline(nrot)) error("Error reading nrotations for atom %i of molecule %i.\n", n+1, m+1);
		skipline((nres-1) / 5);
		skipline(3*nrot);

		count += natoms;
	}

	// Atomtype specifications follow
	// Read in until we find don't find an element symbol (i.e. a number).  
	done = FALSE;
	forcefield ff = newff("Atomtypes from ATO file");
	count = 0;
	do
	{
		++count;
		// Two lines per atomtype
		//   name, symbol, 0/isomass
		//   epsilon  sigma  mass  charge
		if (!readlinef(" %3s %3s", atomname, elname)) error("Error reading atomtype information %i.\n", count);
		if (!readline(eps, sigma, mass, q)) error("Error reading atomtype LJ information %i.\n", count);
		el = aten.findelement(elname);
		if (el == 0) break;
		printf("       : Mapping atom name %s to %s.\n", atomname, el.symbol);
		for (i in aten.model.atoms) if (i.data == atomname) i.element = el;
		ff.addtype(count, atomname, atomname, el, "", "");
		ff.addinter("lj", count, q, eps, sigma);
	} while (!done);

	finalisemodel();
}

filter(type="exportmodel",name="EPSR ATO File", nickname="ato", extension="ato", glob="*.ato", id=18)
{
	# Variable declaration
	model srcmodel= aten.frame;
	pattern p;
	int nmols, n, m, mol, nres, nresa, nrest;
	vector com, r;
	atom i;
	bound b;
	bond bnd;

	# Options
	double temperature = option("Temperature", "doublespin", 0.0, 100000.0, 10.0, 300.0);
	double epsr_tol = option("Tolerance", "doublespin", 0.0, 1.0, 0.0, 0.0, "newline");
	double epsr_itrans = option("Intramolecular Translations", "doublespin", 0.0, 1.0, 1.0, 0.0, "newline", "group=Step Sizes", "span=2");
	double epsr_hrot = option("Headgroup Rotations", "doublespin", 0.0, 10.0, 0.1, 2.5, "newline", "group=Step Sizes", "span=2");
	double epsr_mrot = option("Whole Molecule Rotations", "doublespin", 0.0, 10.0, 0.1, 1.0, "newline", "group=Step Sizes", "span=2");
	double epsr_mtrans = option("Whole Molecule Translations", "doublespin", 0.0, 10.0, 0.01, 0.1, "newline", "group=Step Sizes", "span=2");
	double epsr_vtemp = option("Vibrational Temperature", "doublespin", 0.0, 1500.0, 10.0, 65.0, "newline", "span=2");
	int resbonds = option("Restrain Across Bonds", "check", 1, "newline", "group=Restraints");
	int resangles = option("Restrain Across Angles", "check", 0, "newline", "group=Restraints");
	int restorsions = option("Restrain Across Torsions", "check", 0, "newline", "group=Restraints");

	// First, some checks. We need valid patterns and a cubic cell.
	if (!createpatterns()) error("Error: Can't write ATO file without a valid pattern description.\n");
	if (srcmodel.cell.type != "cubic") error("Error: System must have a cubic cell.\n");

	// Line 1 : nmols, box dimension, temperature
	// First determine total number of molecules
	nmols = 0;      
	for (p in srcmodel.patterns) nmols += p.nmols;
	writelinef("%i   %13.6e  %13.6e\n",nmols,srcmodel.cell.a,temperature);

	// Line 2 : Tol, step sizes (intra trans, headgroup rot, mol rot, mol trans), vibrational temp
	writelinef("  %10.3e  %10.3e  %10.3e  %10.3e  %10.3e  %10.3e\n", epsr_tol, epsr_itrans, epsr_hrot, epsr_mrot, epsr_mtrans, epsr_vtemp);

	// Atom/molecule loop
	mol = 0;
	i = srcmodel.atoms;
	for (p in srcmodel.patterns)
	{
		for (m=1; m<=p.nmols; ++m)
		{
			++mol;
			// Write centre of mass
			com = p.com(m);
			writelinef(" %5i  %13.6e  %13.6e  %13.6e  %6.4f  %6.4f  %6.4f  %5i\n",p.natoms,com.x,com.y,com.z,0.0,0.0,0.0,mol);

			// Write atom information
			for (n=1; n<=p.natoms; ++n)
			{
				if (i.type == 0) writelinef(" %3s  %i", i.symbol, n);
				else writelinef(" %3s  %i", i.type.name, n);

				// Get mim vector to COM
				r = srcmodel.cell.mimd(i.r, com);
				writelinef(" %12.5e %12.5e %12.5e\n", r.x, r.y, r.z);

				// Restraint information
				nres = 0;
				nresa = 0;
				nrest = 0;
				if (resbonds) nres += i.nbonds;
				if (resangles) { for (b in p.angles) if ((b.id[1] == n) || (b.id[3] == n)) ++nresa;
				if (restorsions) { for (b in p.torsions) if ((b.id[1] == n) || (b.id[4] == n)) ++nrest;
				nres += nresa + nrest;
				writelinef(" %4i", nres);
				if (resbonds) for (bnd in i.bonds) { j = bnd.partner(i); writelinef("%4i %9.3e ", j.id-p.firstatomid+1, distance(i,j); }
				if (nresa > 0) for (b in p.angles)
				{
					// Search for angles in which this atom is involved
					if (b.id[1] == n) writelinef("%4i %9.3e ", b.id[3], distance(i.id, i.id+(b.id[3]-b.id[1]));
					else if (b.id[3] == n) writelinef("%4i %9.3e ", b.id[1], distance(i.id, i.id+(b.id[1]-b.id[3]));
				}
				if (nrest > 0) for (b in p.torsions)
				{
					// Search for torsions in which this atom is involved
					if (b.id[1] == n) writelinef("%4i %9.3e ", b.id[4], distance(i.id, i.id+(b.id[4]-b.id[1]));
					else if (b.id[4] == n) writelinef("%4i %9.3e ", b.id[4], distance(i.id, i.id+(b.id[1]-b.id[4]));
				}
				writelinef("\n");

				++i;
			}
		}
	}
}

//	i = sourcemodel->get_atoms();
//	pn = sourcemodel->get_patterns();
//	while (pn != NULL)
//	{
//		mol = &pn->molecule;
//		// Create list of headgroup rotations to write out
//		msg(DM_NONE,"Creating headgroup rotations for pattern '%s'...\n",pn->get_name());
//		nrot = mol->epsr_rotations.get_nitems();
//		if (nrot == 0) hg = "0\n";
//		else
//		{
//			hg = itoa(nrot);
//			hg += "\n";
//			for (ap = mol->epsr_rotations.get_first(); ap != NULL; ap = ap->next)
//			{
//				// Deselect all atoms in molecule, select the first atom of the rotation, then
//				// perform treeselect on the second atom (first selected atom will act as a barrier)
//				mol->deselect_all();
//				mol->select_atom(ap->get_i());
//				mol->tree_select(ap->get_j());
//				mol->deselect_atom(ap->get_i());
//				mol->deselect_atom(ap->get_j());
//				// Selection now contains just the atoms that form the rotation list, so construct string
//				hg += " ROT\n";
//				sprintf(s,"%3i%3i\n ",ap->get_i()->get_id()+1,ap->get_j()->get_id()+1);
//				hg += s;
//				sprintf(s,"%-4i",mol->get_nselected());
//				hg += s;
//				for (j = mol->get_atoms(); j != NULL; j = j->next)
//				{
//					if (j->is_selected())
//					{
//						sprintf(s,"%-4i",j->get_id()+1);
//						hg += s;
//					}
//					j = j->next;
//				}
//				hg += "\n";
//				//printf("nselected = %i\n",mol->get_nselected());
//			}
//		}
//		msg(DM_NONE,"Writing molecules...\n");
//		xff = pn->get_ff();
//		if (xff == NULL) xff = sourcemodel->get_forcefield();
//		if (xff == NULL) printf("No forcefield associated to model - using element names instead of type names...\n");
//		int pnatoms = pn->get_natoms();
//		for (m1=0; m1<pn->get_nmols(); m1++)
//		{
//			com = pn->calculate_com(cfg,m1);
//			sprintf(s," %5i  %13.6e  %13.6e  %13.6e  %6.4f  %6.4f  %6.4f\n",pnatoms,com.x,com.y,com.z,0.0,0.0,0.0);
//			atofile << s;
//			for (a1=0; a1<pnatoms; a1++)
//			{
//				if (xff != NULL) atofile << (i->get_fftype() <= 0 ? " NUL" : xff->get_name(i->get_fftype())) << "\n";
//				else atofile << elements.name(i) << "\n";
//				// Get atomic coordinates relative to COM.
//				mim_i = sourcemodel->cell.mim(i,&com);
//				mim_i -= com;
//				sprintf(s," %13.6e  %13.6e  %13.6e \n",mim_i.x,mim_i.y,mim_i.z);
//				atofile << s;
//				// Write list of restraints.
//				/* OLD VERSION - Just use mim distances between atoms.
//				if (pnatoms > 1)
//				{
//					atofile << pnatoms;
//					for (a2=0; a2<pnatoms; a2++)
//					{
//						if ((a2%5 == 0) && (a2 != 0)) atofile << "\n";
//						mim_i = sourcemodel->cell.mimd(i,&cfg->r[count+a2]);
//						rij = mim_i.magnitude();
//						sprintf(s," %3i  %13.6e ",a2+1,rij);
//						atofile << s;
//					}
//				}
//				else atofile << " 0 ";
//				*/
//				// NEW VERSION - Use restraint list in pattern model
//				nres = mol->get_nrestraints_by_id(a1);
//				if (nres == 0) atofile << " 0 ";
//				else
//				{
//					atofile << nres;
//					ap = mol->epsr_restraints.get_first();
//					count = 0;
//					while (ap != NULL)
//					{
//						// Check if this restraint involves the current atom (a1)
//						if ((a1 == ap->get_i()->get_id()) || (a1 == ap->get_j()->get_id()))
//						{
//							a1 == ap->get_i()->get_id() ? a2 = ap->get_j()->get_id() : a2 = ap->get_i()->get_id();
//							sprintf(s," %3i  %13.6e ",a2+1,ap->get_data());
//							atofile << s;
//							count ++;
//							if ((count%5 == 0) && (count != 0)) atofile << "\n";
//						}
//						ap = ap->next;
//					}
//				}
//				atofile << "\n";
//				i = i->next;
//			}
//			// Write out headgroup rotation data
//			atofile << hg;
//		}
//		pn = pn->next;
//	}
//	// Write the forcefield info
//	msg(DM_NONE,"Writing forcefield data...\n");
//	count = 0;
//	i = sourcemodel->get_atoms();
//	pn = sourcemodel->get_patterns();
//	while (pn != NULL)
//	{
//		xff = pn->get_ff();
//		if (xff == NULL) xff = sourcemodel->get_forcefield();
//		int pnatoms = pn->get_natoms();
//		for (a1=0; a1<pnatoms; a1++)
//		{
//			printf("Atom %i\n",a1);
//			// Check vector list 'names' to see if this ff type has been written out already
//			done = FALSE;
//			for (n=0; n<count; n++)
//				if (names[n] == xff->get_name(i)) done = TRUE;
//			if (!done)
//			{
//				count ++;
//				names.resize(count,"");
//				names[count-1] = xff->get_name(i);
//				sprintf(s," %3s %3s %1i\n",names[count-1].c_str(),elements.symbol(i),0);
//				atofile << s;
//				sprintf(s," %8.4f  %8.4f  %8.4f  %8.4f  %8.4f\n",xff->get_vdw_param(i,VF_LJ_EPS),xff->get_vdw_param(i,VF_LJ_SIGMA),
//					elements.mass(i),0.0,0.0);
//				atofile << s;
//			}
//			i = i->next;
//		}
//		// Skip the rest of the molecule's atoms (neet to maintain correct i*)
//		for (m1=1; m1<pn->get_nmols(); m1++)
//			for (a1=0; a1<pnatoms; a1++)
//				i = i->next;
//		pn = pn->next;
//	}
//	dbg_end(DM_CALLS,"fileimp::write_epsrato");
//	return TRUE;
//}
//

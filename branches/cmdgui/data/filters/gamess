# GAMESS-US Input / Outputi, Logfile and Trajectory Filters (for v1.2+)
# Created:	 14/04/2009
# Last modified: 29/01/2011
# ChangeLog:
#	29/01/2011 - Added COORD option to specify CART or ZMT
#	28/01/2011 - Updated trajectory reader to handle IRC trajectory data
#	15/12/2010 - Added basic trajectory reader
#	09/12/2010 - Updated reading of vibration data from logfile to cope with presence of symmetry line
#	29/10/2010 - Major update to log file filter - ability to read in basis set, MOs, and vibrations added
#	02/10/2010 - Logfile import filter now names models after filenames.
#	14/09/2010 - Tweaks to options output in GUI filter. Standard DFTTYPs added.
#	25/08/2010 - Added GUI options to output filter
#	12/05/2010 - Changed id of log file filter to 11 (was 10, which conflicted with MDL Molfile in 'mol')
#	13/10/2009 - Last frame and parent frame from logfile are now deselected.
# Notes:
#	Output model filter sets symmetry to C1, regardless of the actual symmetry.

filter(type="importtrajectory", name="GAMESS-US Trj File", nickname="gamustrj", extension="trj", glob="*.trj", zmap="name", search="GAMESS VERSION", id=11)
{
        int readHeader()
        {
                return TRUE;
        }

        int readFrame()
        {
		int n, natm, nfrag, nqmmm, packettype, skip = 0;
		string discard, symbol, line;
		double ano, x, y, z;
		model m = aten.frame;

		# MD data packets have three skippable lines at the start
		# IRC data packets have 
		if (find("DATA PACKET",line))
		{
			# Found a data packet - determine which type it is...
			if (contains(line, "===== MD")) { packettype = 1; skip = 3; }
			else if (contains(line, "===== IRC")) { packettype = 2; skip = 1; }
			else
			{
				printf("Unrecognised DATA PACKET type encountered in trj file.\n");
				return FALSE;
			}
		}
		else packettype = 0;

		# Did we find some data?
		if (packettype != 0)
		{
			# Read in number of atoms
			readLine(discard, natm, discard, nfrag, discard, nqmmm);
			skipLine(skip);
			# Read QM atom data (if present)
			if (natm > 0)
			{
				skipLine();
				for (n=0; n<natm; ++n)
				{
					readLine(symbol,ano,x,y,z);
					newAtom(symbol,x,y,z);
				}
			}
			# Read fragment data (if present)
			if (nfrag > 0)
			{
				error("Reading of fragment data from trajectory not implemented yet.");
				skipLine();
				for (n=0; n<nfrag; ++n)
				{
				}
			}
			# Read QMMM data (if present)
			if (nqmmm > 0)
			{
				error("Reading of QMMM data form trajectory not implemented yet.");
				skipLine();
				for (n=0; n<nqmmm; ++n)
				{
				}
			}
			# Specific reads for DATA PACKET types
			if (packettype == 1)
			{
				# Read in velocities for atoms
				if (find("TVELQM(1)"))
				{
					for (n=1; n<=natm; ++n)
					{
						readLine(x, y, z);
						m.atoms[n].v = { x, y, z};
					}
				}
			}
			else if (packettype == 2)
			{
				# Discard mass-weighted gradient
				skipLine(natm+1);
			}
			rebond();
			finaliseModel();
		}
		else return FALSE;
		return TRUE;
	}
}

filter(type="importmodel", name="GAMESS-US Log File", nickname="gamuslog", extension="log", glob="*.log", zmap="name", search="GAMESS VERSION", id=11)
{
	# Variable declaration
	int result,nstructures,natoms,n,l,lastshell,shell,count,orb_no[5];
	Atom i;
	BasisShell bas;
	BasisPrimitive prim;
	EigenVector orbs[5];
	Vibration vibs[5];
	string line,e,name,discard,orb_symm[5],type, vib_imag[5], vib_symm[5];
	double rx,ry,rz, exponent,coeff,orb_nrg[5], orb_coeff[5];
	double vib_freq[5], vib_dx[5], vib_dy[5], vib_dz[5], vib_rmass[5], vib_ir[5];

	# Create a new model, and store its pointer for use later
	model m = newModel(filterFilename());

	# Find initial coordinates (in Bohr)
	if (find("ATOM      ATOMIC                      COORDINATES (BOHR)"))
	{
		skipLine();
		while (readLine(e,discard,rx,ry,rz) != 0) newAtom(e,rx,ry,rz);
		bohr(aten.model);
		rebond();
	}
	else error("No coordinates in file?");

	# Read in basis set information
	if (find("ATOMIC BASIS SET"))
	{
		skipLine(6);
		# Loop over basis shell definitions, stopping when we find the text 'TOTAL'
		readLineF("%s %s %i %f %r", e, name, n, exponent, line);
		#printf("%s %s %i %f [%s]\n", e, name, n, exponent, line);
		lastshell = -1;
		count = 0;
		while (e != "TOTAL")
		{
			# Start of a new atom?
			if (n == 0)
			{
				count ++;
				lastshell = 0;
				#printf("Found start of atom %i, which is element %s\n", count, e);
			}
			else
			{
				# Create new basis shell?
				shell = atoi(e);
				#if (lastshell != shell) printf("Lastn (%i) is != shell (%i), so creating a new shell...\n", lastshell, shell);
				if (lastshell != shell) bas = m.newBasisShell(count, name);
				lastshell = shell;
			}

			# Store primitive's exponent and coefficient(s)
			if (lastshell != 0)
			{
				prim = bas.addPrimitive(exponent);
				# Cycle over provided coefficients
				while (nextVarArg(line,coeff)) prim.addCoefficient(coeff);
			}

			# Get next line, ignoring blanks
			do
			{
				readLineF("%s %s %i %f %r", e, name, n, exponent, line);
			} while (e == "");
			#printf("%s %s %i %f [%s]\n", e, name, n, exponent, line);
		}
		# We end up with the 'TOTAL NUMBER OF BASIS SET SHELLS' line (beginning at 'SET...'), so we can do a check
		readVar(line, discard, discard, discard, n);
		printf("         Number of basis set shells read in : %i\n", m.nBasisShells());
		printf("            --> number specified in logfile : %i\n", n);
		if (n != m.nBasisShells()) error("Failed to read in basis set information.");
		# Also, check the total number of cartesian basis functions
		readLineF("%r", line);
		n = atoi( afterStr(line,"=") );
		printf("Number of implied cartesian basis functions : %i\n", m.nBasisCartesians());
		printf("            --> number specified in logfile : %i\n", n);
		if (n != m.nBasisCartesians()) error("Failed to read in basis set information.");
	}

	# Determine number of atoms - search for line containing 'TOTAL NUMBER OF ATOMS'
	if (!find("TOTAL NUMBER OF ATOMS",line)) error("Couldn't determine number of atoms from GAMESS-US output.");

	# Get number of atoms from line
	readVarF(line, "%48*%i",natoms);

	# Now search for sets of coordinate
	nstructures = 0;
	# Lines containing 'COORDINATES OF ALL ATOMS ARE' are the beginning of coordinate sections
	while (find("COORDINATES OF ALL ATOMS ARE"))
	{
		# Found a set of coordinates. Skip 2 lines and then read coordinates
		nstructures++;
		skipLine(2);
		writeVarF(name, "Frame %i", nstructures);
		m = addFrame(name);
		for (n=1; n<=natoms; ++n)
		{
			readLine(e,discard,rx,ry,rz);
			newAtom(e,rx,ry,rz);
		}
		# Recalculate bonding
		rebond();
		finaliseFrame();
	}

	# Molecular orbitals?
	if (find("MOLECULAR ORBITALS"))
	{
		skipLine(2);
		# MO information is provided 5 orbs per line, in the format:
		#                     1          2          3          4
		#                   -0.5942     0.2657     0.9175     1.5319
		#                     A          A          A          A
		#    1  H  1  S   -0.290651  -0.111641  -0.783160   1.077794
		#    .  .  .  .
		#    NC .  .  .   
		# ...where NC is the number of cartesian basis functions.
		for (n=1; n<m.nBasisShells(); n +=5)
		{
			# Read in orbital numbers as a sanity check
			readLine(discard);
			# End of orbital specification?
			if (atoi(discard) == 0) break;
			else if (n != atoi(discard))
			{
				printf("Failed to read in MO information at orbital number %i (read [%s] from file)\n", n, discard);
				break;
			}
			# Read in eigenvalues and symmetry type
			readLine(orb_nrg[1], orb_nrg[2], orb_nrg[3], orb_nrg[4], orb_nrg[5]);
			readLine(orb_symm[1], orb_symm[2], orb_symm[3], orb_symm[4], orb_symm[5]);
			# Create eigenvectors
			for (l=1; l<6; ++l)
			{
				if ((l+n-1) > m.nBasisShells()) break;
				verbose(" -- Created MO number %i with eigenvalue %f\n", l+n-1, orb_nrg[l]);
				orbs[l] = m.newEigenvector();
				orbs[l].eigenvalue = orb_nrg[l];
				orbs[l].name = orb_symm[l];
			}
			# Next lines contain coefficients...
			for (count=1; count<=m.nBasisCartesians(); ++count)
			{
				readLine(discard,e,shell,type,orb_coeff[1], orb_coeff[2], orb_coeff[3], orb_coeff[4], orb_coeff[5]);
				for (l=1; l<6; ++l)
				{
					if ((l+n-1) > m.nBasisShells()) break;
					orbs[l].vector[count] = orb_coeff[l];
				}
			}
		}
	}

	# Frequencies?
	rewind();
	if (find("FREQUENCIES IN CM**-1"))
	{
		# Skip warning of non-stationary point if present...
		if (find("THIS IS NOT A STATIONARY POINT"))
		{
			skipLine(3);
			printf(" *** The frequencies correspond to a non-stationary point.\n");
		}
		else skipLine(2);
		# Vibration information is provided 5 vibrations per line, in the format:
		#                       1          2          3          4            5
		#    FREQUENCY:      39.84 I     19.94       19.03       15.12       11.87
		#     SYMMETRY:         A          A           A           A           A       (optional)
		# REDUCED MASS:      2.15985     3.96061     4.04986     3.97821     5.98898
		# IR INTENSITY:      0.00121     0.00399     0.00426     0.00020     0.00070
		#  <blank line>
		#    1  HYDROGEN  X  0.05470495  0.01254668 -0.05069468  0.01778118 -0.01077563
		#    .  .  .  .
		#    3N .  .  .   
		# ...where N is the number of atoms in the model
		for (n=1; n<3*m.nAtoms(); n +=5)
		{
			# Read in vibration numbers as a sanity check
			readLine(discard);
			if (n != atoi(discard))
			{
				printf("Failed to read in vibration information at vibration number %i (read [%s] from file)\n", n, discard);
				break;
			}
			# Read in frequencies and imaginary flags
			readLineF("%* %f%2s%f%2s%f%2s%f%2s%f%2s", vib_freq[1], vib_imag[1], vib_freq[2], vib_imag[2], vib_freq[3], vib_imag[3], vib_freq[4], vib_imag[4], vib_freq[5], vib_imag[5]);
			readLineF("%18s %r", discard, line);
			if (stripChars(discard," ") == "REDUCEDMASS:") readVar(line, vib_rmass[1], vib_rmass[2], vib_rmass[3], vib_rmass[4], vib_rmass[5]);
			else
			{
				readVar(line, vib_symm[1], vib_symm[2], vib_symm[3], vib_symm[4], vib_symm[5]);
				readLine(discard, vib_rmass[1], vib_rmass[2], vib_rmass[3], vib_rmass[4], vib_rmass[5]);
			}
			readLine(discard, vib_ir[1], vib_ir[2], vib_ir[3], vib_ir[4], vib_ir[5]);
			# Create vibrations
			for (l=1; l<6; ++l)
			{
				if ((l+n-1) > 3*m.nAtoms()) break;
				if (contains(vib_imag[l],"I")) vib_freq[l] = -vib_freq[l];
				verbose("Created vibration number %i with frequency %f\n", l+n-1, vib_freq[l]);
				vibs[l] = m.newVibration();
				vibs[l].frequency = vib_freq[l];
			}
			skipLine(1);
			# Next lines contain atomic displacements
			for (count=1; count<=m.nAtoms(); ++count)
			{
				readLine(discard,e,type,vib_dx[1], vib_dx[2], vib_dx[3], vib_dx[4], vib_dx[5]);
				readLine(type,vib_dy[1], vib_dy[2], vib_dy[3], vib_dy[4], vib_dy[5]);
				readLine(type,vib_dz[1], vib_dz[2], vib_dz[3], vib_dz[4], vib_dz[5]);
				for (l=1; l<6; ++l)
				{
					if ((l+n-1) > 3*m.nAtoms()) break;
				#	vibs[l].displacements[count] = { vib_dx[l], vib_dy[l], vib_dz[l] };
					vibs[l].displacements[count].x = vib_dx[l] ;
					vibs[l].displacements[count].y = vib_dy[l] ;
					vibs[l].displacements[count].z = vib_dz[l] ;
				}
			}
			# Skip over Sayvetz information
			skipLine(11);
		}
		printf("Read in data for %i vibrations.\n", m.nVibrations());
	}

	# Atomic Charges
	rewind();
	if (find("ELECTROSTATIC POTENTIAL"))
	{
		# Skip to last section
		do { }
		while (find("ELECTROSTATIC POTENTIAL"));
		# Now search for "NET CHARGES"
		if (find("NET CHARGES"))
		{
			skipLine(3);
			for (i = m.atoms; i; ++i) readLine(discard, i.q);
			printf("Found and read in ESP charges.\n");
		}
	}

	finaliseModel();
}

filter(type="importmodel", name="GAMESS-US Cartesian Input", nickname="gamusinp", extension="inp", glob="*.inp", zmap="name", id=5)
{
	# Variables
	string symm,symbol,title;
	int n,z;
	double rx,ry,rz;

	# Search for $DATA section
	if (!find("DATA")) error("Couldn't find 'DATA' section in input file.");

	# Read in title card
	getLine(title);
	newModel(title);

	# Skip over symmetry specification
	readLine(symm);
	if (symm <> "C1")
	{
		# Single blank line means the master frame is in use, and only this line to skip
		readLine(symm);
		if (symm != "") skipLine();
	}
	
	# Coordinates follow, terminated by $END
	readLine(symbol,z,rx,ry,rz);
	while (symbol != "$END")
	{
		newAtom(symbol,rx,ry,rz);
		readLine(symbol,z,rx,ry,rz);
	}

	# Done
	rebond();
	finaliseModel();
}

filter(type="exportmodel", name="GAMESS-US Input", nickname="gamusinp", extension="inp", glob="*.inp", id=5)
{
	#
	# GUI Control Definitions
	#
	void defaultUi()
	{
		dialog ui = defaultDialog("GAMESS-US Export Options");
		widget group, w, tabs, page;

		# General control options group ($CONTRL)
		group = ui.addGroup("jobgroup", "Job Control ($CONTRL)", 1, 1);
		group.addCombo("contrl_runtyp", "Run Type", "ENERGY,GRADIENT,HESSIAN,GAMMA,OPTIMIZE,TRUDGE,SADPOINT,MEX,IRC,VSCF,DRC,MD,GLOBOP,OPTFMO,GRADEXTR,SURFACE,G3MP2,PROP,RAMAN,NACME,NMR,EDA,TRANSITN,FFIELD,TDHF,TDHFX,MAKEFP,FMO0", 5, 1, 1);
		group.addCombo("contrl_scftyp", "SCF Type", "RHF,UHF,ROHF,GVB,MCSCF,NONE", 1, 3, 1);
		group.addIntegerSpin("contrl_mult", "Multiplicity", 1, 8, 1, 1, 5, 1);
		group.addIntegerSpin("contrl_charge", "Charge", -1000, 1000, 1, 0, 7, 1);
		w = group.addCombo("contrl_dft", "DFT", "NONE,GRID,GRIDFREE", 1, 1, 2);
		#w.onStringValue("dftpage", "disabled", "NONE");
		group.addCombo("contrl_tddft", "TDDFT Type", "NONE,EXCITE", 1, 3, 2);
		group.addCombo("contrl_mplevl", "MP Level", "0,2", 1, 5, 2);
		group.addCombo("contrl_cityp", "CI Type", "NONE,CIS,ALDET,ORMAS,FSOCI,GENCI,GUGA", 1, 7, 2);
		group.addCombo("contrl_cctyp", "CC Type", "NONE,LCCD,CCD,CCSD,CCSD(T),R-CC,CR-CC,CR-CCL,CCSD(TQ),CR-CC(Q),EOM-CCSD,CR-EOM,CR-EOML,IP-EOM2,EA-EOM2,EA-EOM3A", 1, 1, 3);
		group.addCombo("contrl_relwfn", "Rel. Wfn.", "NONE,DK,RESC,NESC", 1, 3, 3);
		group.addCombo("contrl_exetyp", "Exe Type", "RUN,CHECK,DEBUG", 1, 5, 3);
		group.addCombo("contrl_pp", "Pseudo", "NONE,READ,SBKJC,HW,MCP", 1, 7, 3);
		group.addCombo("contrl_coord", "Coord Type", "UNIQUE,ZMT", 1, 1, 4);
		group.addCheck("cart_symbols", "Use Symbols", 1, 3, 4, 1);
		group.addIntegerSpin("contrl_maxit", "Max SCF It.", 1, 1000, 10, 30, 5, 4);

		# Basis set specification ($BASIS)
		group = ui.addGroup("basisgroup", "Basis Set ($BASIS)", 1, 2);
		w = group.addCombo("basis_gbasis", "Basis", "MINI,MIDI,STO,N21,N31,N311,DZV,DH,TZV,MC,CCD,CCT,CCQ,CC5,CC6,ACCD,ACCT,ACCQ,ACC5,ACC6,CCDC,CCTC,CCQC,CC5C,CC6C,ACCDC,ACCTC,ACCQC,ACC5C,ACC6C,PC0,PC1,PC2,PC3,PC4,APC0,APC1,APC2,APC3,APC4,SBKJC,HW,MCP-DZP,MCP-TZP,MCP-QZP,IMCP-SR1,IMCP-SR2,IMCP-NR1,IMCP-NR2,MNDO,AM1,PM3", 5, 1, 1);
		#w.onIntegerValue(1, 9 TZV, "basisstack", "value", 1);
		w = group.addStack("basisstack", 1, 2);
		page = w.addPage("");
		group.addIntegerSpin("basis_ngauss", "NGAUSS", 3, 8, 1, 6, 1, 1);
		group.addIntegerSpin("basis_ndfunc", "NDFUNC", 0, 3, 1, 0, 3, 1);
		group.addIntegerSpin("basis_npfunc", "NPFUNC", 0, 3, 1, 0, 5, 1);
		group.addIntegerSpin("basis_nffunc", "NFFUNC", 0, 1, 1, 0, 7, 1);
		group.addCheckBox("basis_diffsp", "DIFFSP", 0, 1, 2);
		group.addCheckBox("basis_diffs", "DIFFS", 0, 3, 2);

		# Tabs containing various options
		tabs = ui.addTabs("optiontabs", 1, 3);
		
		# DFT options ($DFT)
		page = tabs.addPage("dftpage", "$DFT");
		string griddfttyps = "NONE,SLATER,BECKE,GILL,OPTX,PW91X,PBEX,VWN,VWN1,PZ81,P86,LYP,PW91C,PBEc,OP,SVWN,BLYP,BOP,BP86,GVWN,GPW91,PBEVWN,PBEOP,OLYP,EDF1,PW91,PBE,revPBE,RPBE,PBEsol,HCTH93,HCTH120,HCTH147,HCTH407,SOGGA,MOHLYP,B97-D,BHHLYP,B3PW91,B3LYP,B3LYP1,B97,B97-1,B97-2,B97-3,B97-K,B98,PBE0,X3LYP,CAMB3LYP,wB97,wB97X,wB97X-D,B2PLYP,wB97X-2,wB97X-2L,VS98,PKZB,tHCTH,tHCTHhyb,BMK,TPSS,TPSSh,TPSSm,revTPSS,M05,M05-2X,M06,M06-L,M06-2X,M06-HF,M08-HX,M08-SO";
		string gridfreedfttyps = "NONE,XALPHA,SLATER,BECKE,DEPRISTO,CAMA,HALF,VWN,PWLOC,LYP,BVWN,BLYP,BPWLOC,B3LYP,CAMB,XVWN,XPWLOC,SVWN,SPWLOC,WIGNER,WS,WIGEXP";
		#w = page.addCombo("dftgrid", "DFT Method", "GRID,GRIDFREE", 1, 1, 1);
		w.onInteger(1, 1, "contrl_dfttyp", "items", griddfttyps);
		w.onInteger(2, 2, "contrl_dfttyp", "items", "NONE,XALPHA,SLATER,BECKE,DEPRISTO,CAMA,HALF,VWN,PWLOC,LYP,BVWN,BLYP,BPWLOC,B3LYP,CAMB,XVWN,XPWLOC,SVWN,SPWLOC,WIGNER,WS,WIGEXP");
		w.onInteger(1, 2, "contrl_dfttyp", "value", 2);

		# Stationary point location options ($STATPT)
		page = tabs.addPage("page_statpt", "$STATPT");
		page.addCombo("statpt_method", "METHOD", "NR,RFO,QA,SCHLEGEL,CONOPT", 3, 1, 1);
		page.addDoubleSpin("statpt_opttol", "OPTTOL", 0.0, 1.0, 0.0001, 0.0001, 3, 1);
		page.addIntegerSpin("statpt_nstep", "NSTEP", 1, 1000000, 5, 20, 5, 1);
		page.addIntegerSpin("statpt_ifolow", "IFOLOW", 1, 100000, 1, 1, 1, 2); 
		page.addCheck("statpt_stpt", "STPT", 0, 3, 2);
		page.addDoubleSpin("statpt_ststep", "STSTEP", 0.0, 1.0, 0.005, 0.01, 5, 2);
		page.addEdit("statpt_ifreez", "IFREEZ", "", 3, 5);
		page.addCombo("statpt_hess", "HESS", "GUESS,READ,RDAB,RDALL,CALC", 1, 1, 4);
		page.addIntegerSpin("statpt_ihrep", "IHREP", 0, 1000, 1, 0, 3, 4);
		page.addCheck("statpt_hssend", "HSSEND", 0, 5, 4);

		# Intrinsic reaction coordinate run ($IRC)
		page = tabs.addPage("page_irc", "$IRC");
		page.addCheck("irc_forwrd", "FORWRD", 1, 1, 1);
		page.addCheck("irc_saddle", "SADDLE", 1, 3, 1);
		page.addDoubleSpin("irc_stride", "STRIDE", 0.001, 1.0, 0.05, 0.3, 5, 1);
		page.addIntegerSpin("irc_npoint", "NPOINT", 1, 1000, 5, 1, 7, 1);
		page.addCombo("irc_pace", "PACE", "GS2,LINEAR,QUAD,AMPC4,RK4", 1, 1, 2);

		# Electron density calculation ($ELDENS)
		page = tabs.addPage("page_eldens", "$ELDENS");
		page.addCheck("eldens_ieden", "Calculate?", 0, 1, 1);
		page.addIntegerSpin("eldens_morb", "MORB", 0, 10000, 1, 0, 3, 1);
		page.addCombo("eldens_where", "WHERE", "COMASS,NUCLEI,POINTS,GRID", 2, 5, 1);
		page.addCombo("eldens_output", "OUTPUT", "PUNCH,PAPER,BOTH", 3, 7, 1);

		# Electrostatic potential calculation ($ELPOT)
		page = tabs.addPage("page_elpot", "$ELPOT");
		page.addCheck("elpot_iepot", "Calculate", 0, 1, 1);
		page.addCombo("elpot_where", "WHERE", "COMASS,NUCLEI,POINTS,GRID,PDC", 2, 3, 1);
		page.addCombo("elpot_output", "OUTPUT" "PUNCH,PAPER,BOTH,NONE", 3, 5, 1);

		# Point selection ($PDC)
		page = tabs.addPage("page_pdc", "$PDC");
		page.addCombo("pdc_ptsel", "PTSEL", "GEODESIC,CONNOLLY,CHELPG", 1, 1, 1);
		page.addCombo("pdc_constr", "CONSTR", "NONE,CHARGE,DIPOLE,QUPOLE", 2, 3, 1);

	# Grid specification ($GRID), placed in 'opts' tabs
	int grid_modgrd = option("3D Grid", "check", 0, "tab=$GRID@opts", "newline");
	double grid_size = option("Grid Increment", "doublespin", 0.00001, 2.0, 0.1, 0.25, "tab=$GRID@opts");
	option("ORIGIN", "label", "newline", "tab=$GRID@opts");
	double grid_originx = option("X", "doublespin", -1000.0, 1000, 1, -10.0, "tab=$GRID@opts");
	double grid_originy = option("Y", "doublespin", -1000.0, 1000, 1, -10.0, "tab=$GRID@opts");
	double grid_originz = option("Z", "doublespin", -1000.0, 1000, 1, -10.0, "tab=$GRID@opts");
	option("XVEC", "label", "newline", "tab=$GRID@opts");
	double grid_xvecx = option("X", "doublespin", -1000.0, 1000, 1,  10.0, "tab=$GRID@opts");
	double grid_xvecy = option("Y", "doublespin", -1000.0, 1000, 1, -10.0, "tab=$GRID@opts");
	double grid_xvecz = option("Z", "doublespin", -1000.0, 1000, 1, -10.0, "tab=$GRID@opts");
	option("YVEC", "label", "newline", "tab=$GRID@opts");
	double grid_yvecx = option("X", "doublespin", -1000.0, 1000, 1, -10.0, "tab=$GRID@opts");
	double grid_yvecy = option("Y", "doublespin", -1000.0, 1000, 1,  10.0, "tab=$GRID@opts");
	double grid_yvecz = option("Z", "doublespin", -1000.0, 1000, 1, -10.0, "tab=$GRID@opts");
	option("ZVEC", "label", "newline", "tab=$GRID@opts");
	double grid_zvecx = option("X", "doublespin", -1000.0, 1000, 1, -10.0, "tab=$GRID@opts");
	double grid_zvecy = option("Y", "doublespin", -1000.0, 1000, 1, -10.0, "tab=$GRID@opts");
	double grid_zvecz = option("Z", "doublespin", -1000.0, 1000, 1,  10.0, "tab=$GRID@opts");

		# PCM options ($PCM), placed in 'opts' tab
		page = tabs.addPage("page_pcm", "$PCM");
		page.addCombo("pcm_solvnt", "Solvent", "NONE,WATER,CH3OH,CLFORM,METHYCL,BENZENE,CLBENZ,NEPTANE,ANILINE,C2H5OH,CTCL,12DCLET,TOLUENE,NITMET,CYCHEX,ACETONE", 1, 1, 1);

	};

	# Grab default dialog pointer
	dialog ui = defaultDialog();

	#
	# Write Data
	#
	string line;
	# Write $CONTRL line(s)
	writelinef(" $CONTRL SCFTYP=%s RUNTYP=%s COORD=%s ICHARG=%i MULT=%i $END\n", ui.asString("contrl_scftyp"), ui.asString("contrl_runtyp"), ui.asString("contrl_coord"), ui.asInteger("contrl_charge"), ui.asInteger("contrl_mult"));
	line = "";
	if (contrl_dfttyp != "NONE") line += " DFTTYP=" + contrl_dfttyp;
	if (contrl_tddft != "NONE") line += " TDDFT=" + contrl_tddft;
	if (contrl_mplevl != "0") line += " MPLEVL=" + contrl_mplevl;
	if (contrl_cityp != "NONE") line += " CITYP=" + contrl_cityp;
	if (contrl_cctyp != "NONE") line += " CCTYP=" + contrl_cctyp;
	if (contrl_pp != "NONE") line += " ECPTYP=" + contrl_pp;
	if (contrl_maxit != 30) line += " MAXIT=" + itoa(contrl_maxit);
	if (line != "") writelinef(" $CONTRL%s $END\n", line);

	# Write $BASIS line(s)
	if ((basis_gbasis == "STO") || (basis_gbasis == "N21") || (basis_gbasis == "N31") || (basis_gbasis == "N311"))
	{
		sprintf(line, "GBASIS=%s NGAUSS=%i", basis_gbasis, basis_ngauss);
		if (basis_ndfunc != 0) line += " NDFUNC=" + itoa(basis_ndfunc);
		if (basis_npfunc != 0) line += " NPFUNC=" + itoa(basis_npfunc);
		if (basis_nffunc != 0) line += " NFFUNC=" + itoa(basis_nffunc);
		writelinef(" $BASIS %s $END\n", line);
		if (basis_diffsp == ".TRUE." || basis_diffs == ".TRUE.") writelinef(" $BASIS DIFFSP=%s DIFFS=%s $END\n", basis_diffsp, basis_diffs);
	}
	else writelinef(" $BASIS GBASIS=%s $END\n", basis_gbasis);

	# Write additional groups, depending on job type
	if ((contrl_runtyp == "OPTIMIZE") || (contrl_runtyp == "SADPOINT"))
	{
		writevarf(line, " $STATPT METHOD=%s NSTEP=%i OPTTOL=%f HESS=%s", statpt_method, statpt_nstep, statpt_opttol, statpt_hess);
		if (statpt_ihrep != 0) line += " IHREP=" + itoa(statpt_ihrep);
		if (statpt_hssend == ".TRUE.") line += " HSSEND=.TRUE.";
		writelinef("%s $END\n", line);
		if (contrl_runtyp == "SADPOINT") writelinef(" $STATPT IFOLOW=%i STPT=%s STSTEP=%f $END\n", statpt_ifolow, statpt_stpt, statpt_ststep);
		if (statpt_ifreez != "") writelinef(" $STATPT IFREEZ(1)=%s $END\n", statpt_ifreez);
	}
	else if (contrl_runtyp == "IRC") writelinef(" $IRC PACE=%s FORWRD=%s SADDLE=%s STRIDE=%f NPOINT=%i $END\n", irc_pace, irc_forwrd, irc_saddle, irc_stride, irc_npoint);

	# Write $ELDENS if required
	if (eldens_ieden == 1) writelinef(" $ELDEN IEDEN=1 MORB=%i WHERE=%s OUTPUT=%s $END\n", eldens_morb, eldens_where, eldens_output);

	# Write $ELPOT if required
	if (elpot_iepot == 1)
	{
		writelinef(" $ELPOT IEPOT=1 WHERE=%s OUTPUT=%s $END\n", elpot_where, elpot_output);
		if (elpot_where == "PDC") writelinef(" $PDC PTSEL=%s CONSTR=%s $END\n", pdc_ptsel, pdc_constr);
	}

	# Write $GRID if required
	if ((eldens_where == "GRID") || (elpot_where == "GRID"))
	{
		writelinef(" $GRID MODGRD=%i UNITS=ANGS SIZE=%f $END\n", grid_modgrd, grid_size);
		writelinef(" $GRID ORIGIN(1)=%f ORIGIN(2)=%f ORIGIN(3)=%f $END\n", grid_originx, grid_originy, grid_originz);
		writelinef(" $GRID XVEC(1)=%f XVEC(2)=%f XVEC(3)=%f $END\n", grid_xvecx, grid_xvecy, grid_xvecz);
		writelinef(" $GRID YVEC(1)=%f YVEC(2)=%f YVEC(3)=%f $END\n", grid_yvecx, grid_yvecy, grid_yvecz);
		if (grid_modgrd == 1) writelinef(" $GRID ZVEC(1)=%f ZVEC(2)=%f ZVEC(3)=%f $END\n", grid_zvecx, grid_zvecy, grid_zvecz);
	}

	# Write $PCM if required
	if (pcm_solvnt != "NONE")
	{
		writelinef(" $PCM SOLVNT=%s $END\n", pcm_solvnt);
	}

	# Write $SYSTEM, $GUESS, and $SCF groups
	writeline(" $SYSTEM MEMDDI=16 TIMLIM=2400 MWORDS=96 $END");
	writeline(" $GUESS GUESS=HUCKEL $END");
	writeline(" $SCF DIRSCF=.TRUE. $END");

	# Now for the DATA section
	writeline(" $DATA");
	writeline(aten.frame.name);
	writeline("C1");
	if (contrl_coord == "CART")
	{
		if (cart_symbols) for (atom i = aten.frame.atoms; i != 0; ++i) writelinef("%-15s  %4.1f  %12.6f %12.6f %12.6f\n", i.symbol,i.z*1.0,i.rx,i.ry,i.rz);
		else for (atom i = aten.frame.atoms; i != 0; ++i) writelinef("%-15s  %4.1f  %12.6f %12.6f %12.6f\n", i.name,i.z*1.0,i.rx,i.ry,i.rz);
	}
	else writezmatrix(aten.frame);
	writeline(" $END");
}

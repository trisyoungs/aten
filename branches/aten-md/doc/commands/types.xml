	<indexterm zone="command.types"><primary>variables</primary><secondary>types</secondary></indexterm>
	
	<para>For variables in Aten that are of reference type (i.e. the non-standard types) various sub-variables and functions may be accessed in the same way class members are utilised in C++. Each non-standard variable type is listed here along with the types and descriptions of their available subvariables / members.</para>
	
	<para>In the same way that class members are accessed in C/C++, subvariables of reference types are accessed by use of the full stops '.' between member names. For instance, the <link linkend="command.types.atom">atom</link> type allows all the information of a given atom to be accessed. The following example illustrates the process of retrieving the third atom in the current model, finding its coordinates, and subsequently adjusting them:</para>
	
	<synopsis>
		atom a = aten.model.atoms[3];
		vector v = a.r;
		printf(&quot;Old coordinates are: %f %f %f\n&quot;, v.x, v.y, v.z);
		v.x += 4.0;
		a.r = v;
		printf(&quot;New coordinates are: %f %f %f\n&quot;, a.rx, a.ry, a.rz);
	</synopsis>
	
	<para>Lots of paths are used here. Firstly, the global <link linkend="command.types.aten">aten</link> variable is used to get access to the current model and grab a reference to its third atom (aten.model.atoms[3]). Then, the coordinates of this atom are placed in a vector <emphasis>v</emphasis> by requesting the <emphasis>r</emphasis> subvariable from the stored <link linkend="command.types.atom">atom</link> reference. We then adjust the vector and store the new coordinates in the atom.</para>
	
	<para>All subvariables can be read, but not all can be written back to - these are read-only subvariables, and are indicated with 'ro' in the <emphasis>Access</emphasis> column in the following tables.</para>
	
	<para>Function members act in the same as subvariable members except that they take one or more arguments enclosed in parentheses immediately following the member name, just as command functions do.</para>
	
	<section id="command.types.arrays"><title>Arrays</title>
		
		<indexterm zone="command.types.arrays"><primary>variables</primary><secondary>arrays</secondary></indexterm>
		<indexterm zone="command.types.arrays"><primary>types</primary><secondary>arrays</secondary></indexterm>
		
		<para>Many types have some subvariables that are arrays, with individual elements accessed by use of square brackets containing the array index in the same way as user-declared arrays:</para>
		
		<synopsis>
			int i[10];
			int j = i[9];
			model m = aten.models[5];
		</synopsis>
		
		<para>For subvariables that are arrays of <emphasis>plain</emphasis> datatypes (int, double, string, or vector) the array index may be omitted and the whole array will be returned/accessed rather than an individual element. For subvariables that are arrays of pointer/reference types (e.g. <link linkend="command.types.atom">atom</link>, <link linkend="command.types.bond">bond</link>, <link linkend="command.types.unitcell">unitcell</link> etc.) omitting the array index returns the first item in the array (if any). Why? Aten stores most of its dynamic data in linked lists, and so returning this as a proper array complicates matters a little (more from the perspective of implementation alongside the existing code rather than any pathological problem).</para>
	
	</section>
